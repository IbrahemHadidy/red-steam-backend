{"version":3,"sources":["../../../../../src/modules/repositories/sql/users/users.service.ts"],"sourcesContent":["// NestJS\r\nimport {\r\n  BadRequestException,\r\n  ConflictException,\r\n  Injectable,\r\n  InternalServerErrorException,\r\n  Logger,\r\n  NotFoundException,\r\n} from '@nestjs/common';\r\n\r\n// TypeORM\r\nimport { InjectRepository } from '@nestjs/typeorm';\r\nimport { FindOptionsOrder, FindOptionsRelations, FindOptionsWhere, ILike, Repository } from 'typeorm';\r\n\r\n// Services\r\nimport { GamesTagsService } from '@repositories/sql/games-tags/games-tags.service';\r\n\r\n// Entities\r\nimport { CartItem, LibraryItem, User, WishlistItem } from '@repositories/sql/users/user.entity';\r\n\r\n// Types\r\nimport type { User as UserType } from '@repositories/sql/users/user.entity';\r\n\r\n@Injectable()\r\nexport class UsersService {\r\n  private readonly relations: FindOptionsRelations<User>;\r\n\r\n  constructor(\r\n    private readonly logger: Logger,\r\n    @InjectRepository(User, 'sql')\r\n    private readonly userRepository: Repository<User>,\r\n    private readonly gameTag: GamesTagsService,\r\n  ) {\r\n    this.relations = { tags: true };\r\n  }\r\n\r\n  /**\r\n   * Retrieves all users.\r\n   * @param orderBy - The property to order by.\r\n   * @param order - The order to use.\r\n   * @return A Promise that resolves to an array of user entities.\r\n   */\r\n  public async getAll(\r\n    orderBy: 'id' | 'email' | 'username' | 'country' | 'createdAt',\r\n    order: 'ASC' | 'DESC',\r\n  ): Promise<UserType[]> {\r\n    this.logger.log(`Retrieving all users from the database`);\r\n\r\n    // Retrieve all users\r\n    const users = await this.userRepository.find({ relations: this.relations, order: { [orderBy]: order } });\r\n\r\n    // Return the users\r\n    return users;\r\n  }\r\n\r\n  /**\r\n   * Retrieves a user by their ID.\r\n   * @param id - The ID of the user to retrieve.\r\n   * @return A Promise that resolves to the user entity.\r\n   */\r\n  public async getById(id: string, reviews?: boolean): Promise<UserType> {\r\n    this.logger.log(`Retrieving user with ID ${id} from the database`);\r\n\r\n    // Get the user by ID\r\n    const user = await this.userRepository.findOne({ where: { id }, relations: { tags: true, reviews } });\r\n\r\n    // Return the user\r\n    return user;\r\n  }\r\n\r\n  /**\r\n   * Retrieves a user by their username.\r\n   * @param username - The username of the user to retrieve.\r\n   * @return A Promise that resolves to the user entity or null if the user is not found.\r\n   */\r\n  public async getByUsername(username: string, reviews?: boolean): Promise<UserType> {\r\n    this.logger.log(`Retrieving user with username ${username} from the database`);\r\n\r\n    // Get the user by username\r\n    const user = await this.userRepository.findOne({ where: { username }, relations: { tags: true, reviews } });\r\n\r\n    // Return the user\r\n    return user;\r\n  }\r\n\r\n  /**\r\n   * Retrieves a user by their email address.\r\n   * @param email - The email address of the user to retrieve.\r\n   * @param reviews - Whether to include reviews in the search.\r\n   * @return A Promise that resolves to the user entity or null if the user is not found.\r\n   */\r\n  public async getByEmail(email: string, reviews?: boolean): Promise<UserType | null> {\r\n    this.logger.log(`Retrieving user with email ${email} from the database`);\r\n\r\n    // Get the user by email\r\n    const user = await this.userRepository.findOne({ where: { email }, relations: { tags: true, reviews } });\r\n\r\n    // Return the user\r\n    return user;\r\n  }\r\n\r\n  /**\r\n   * Retrieves a user by their email or username.\r\n   * @param emailOrUsername - The email or username of the user to retrieve.\r\n   * @return A Promise that resolves to the user entity or null if the user is not found.\r\n   */\r\n  public async getByEmailOrUsername(emailOrUsername: string, reviews?: boolean): Promise<UserType> {\r\n    this.logger.log(`Retrieving user with identifier: ${emailOrUsername} from the database`);\r\n\r\n    // Get the user by email\r\n    const user = await this.userRepository.findOne({\r\n      where: [{ email: emailOrUsername }, { username: emailOrUsername }],\r\n      relations: { tags: true, reviews },\r\n    });\r\n\r\n    // Return the user\r\n    return user;\r\n  }\r\n\r\n  /**\r\n   * Retrieves a user by their verification token.\r\n   * @param token - The verification token of the user to retrieve.\r\n   * @return A Promise that resolves to the user entity or null if the user is not found.\r\n   */\r\n  public async getByVerificationToken(token: string): Promise<UserType> {\r\n    this.logger.log(`Retrieving user with verification token ${token} from the database`);\r\n\r\n    // Get the user by verification token\r\n    const user = await this.userRepository.findOne({ where: { verificationToken: token }, relations: this.relations });\r\n\r\n    // Return the user\r\n    return user;\r\n  }\r\n\r\n  /**\r\n   * Retrieves a user by their phone number.\r\n   * @param phoneNumber - The phone number of the user to retrieve.\r\n   * @return A Promise that resolves to the user entity.\r\n   * @throws `NotFoundException` if the user with the specified phone number is not found.\r\n   */\r\n  public async getByPhoneNumber(phoneNumber: string): Promise<UserType> {\r\n    this.logger.log(`Retrieving user with phone number ${phoneNumber} from the database`);\r\n\r\n    // Get the user by phone number\r\n    const user = await this.userRepository.findOne({ where: { phoneNumber }, relations: this.relations });\r\n\r\n    // Return the user\r\n    if (!user) throw new NotFoundException(`User with phone number ${phoneNumber} not found`);\r\n\r\n    // Return the user\r\n    return user;\r\n  }\r\n\r\n  /**\r\n   * Gets paginated user.\r\n   * @param page - The current page number.\r\n   * @param limit - The number of items per page.\r\n   * @param orderBy - The field to order by.\r\n   * @param order - The order direction.\r\n   * @param searchQuery - The search query.\r\n   * @returns A promise that resolves to the paginated users.\r\n   */\r\n  public async getUsersPaginated(\r\n    page: number,\r\n    limit: number,\r\n    orderBy: 'username' | 'email' | 'country' | 'isVerified' | 'isAdmin' | 'createdAt',\r\n    order: 'ASC' | 'DESC',\r\n    searchQuery?: { username?: string; email?: string },\r\n  ): Promise<{ items: UserType[]; total: number; totalPages: number }> {\r\n    this.logger.log(`Getting users paginated: page ${page}, limit ${limit}, order by ${orderBy} ${order}`);\r\n\r\n    // Create the where clause\r\n    const where: FindOptionsWhere<User> = {};\r\n    if (searchQuery?.username) {\r\n      where.username = ILike(`%${searchQuery.username}%`);\r\n    }\r\n    if (searchQuery?.email) {\r\n      where.email = ILike(`%${searchQuery.email}%`);\r\n    }\r\n\r\n    // Create the order options\r\n    const orderOptions: FindOptionsOrder<User> = {};\r\n    if (orderBy === 'username') {\r\n      orderOptions.username = order;\r\n    } else if (orderBy === 'email') {\r\n      orderOptions.email = order;\r\n    } else if (orderBy === 'country') {\r\n      orderOptions.country = order;\r\n      0;\r\n    } else if (orderBy === 'isVerified') {\r\n      orderOptions.isVerified = order;\r\n    } else if (orderBy === 'isAdmin') {\r\n      orderOptions.isAdmin = order;\r\n    } else if (orderBy === 'createdAt') {\r\n      orderOptions.createdAt = order;\r\n    }\r\n\r\n    // Get the users\r\n    const [items, total] = await this.userRepository.findAndCount({\r\n      where,\r\n      relations: this.relations,\r\n      order: orderOptions,\r\n      skip: Math.max((page - 1) * limit, 0),\r\n      take: limit,\r\n    });\r\n\r\n    // Get the total number of pages\r\n    const totalPages = Math.ceil(total / limit);\r\n\r\n    // Return the users\r\n    return { items, total, totalPages };\r\n  }\r\n\r\n  /**\r\n   * Creates a new user.\r\n   * @param user - The user entity to be created.\r\n   * @return A Promise that resolves to the created user entity.\r\n   * @throws `ConflictException` if the user already exists.\r\n   * @throws `InternalServerErrorException` if the creation fails.\r\n   */\r\n  public async create(user: { email: string; username: string; country: string; password: string }): Promise<UserType> {\r\n    this.logger.log(`Creating user with email ${user.email} in the database`);\r\n\r\n    // Check if user already exists\r\n    const existingUser = await this.userRepository.findOne({\r\n      where: [{ email: user.email }, { username: user.username }],\r\n    });\r\n    if (existingUser) throw new ConflictException('User already exists');\r\n\r\n    // Initialize reviews as an empty array\r\n    const newUser = new User();\r\n    newUser.email = user.email;\r\n    newUser.username = user.username;\r\n    newUser.country = user.country;\r\n    newUser.password = user.password;\r\n    newUser.reviews = [];\r\n\r\n    // Save the user\r\n    const createdUser = await this.userRepository.save(newUser);\r\n\r\n    // Throw an exception if the user was not created\r\n    if (!createdUser) throw new InternalServerErrorException('Failed to create user');\r\n\r\n    // Return the created user\r\n    return createdUser;\r\n  }\r\n\r\n  /**\r\n   * Updates a user entity with new attributes.\r\n   * @param id - The ID of the user entity to update.\r\n   * @param attrs - The partial attributes to update the user entity with.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user with the specified ID is not found.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async update(id: string, attrs: Partial<UserType>): Promise<UserType> {\r\n    this.logger.log(`Updating user with ID ${id} in the database`);\r\n\r\n    // Check if user exists\r\n    const user = await this.getById(id);\r\n\r\n    // Throw an exception if user is not found\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Update the user\r\n    Object.assign(user, attrs);\r\n\r\n    // Save the updated user\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the user was not updated\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Sets the login status of a user.\r\n   * @param id - The ID of the user.\r\n   * @param loggedIn - The login status to set.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async setLoginStatus(id: string, loggedIn: boolean): Promise<UserType> {\r\n    this.logger.log(`Updating login status of user with ID ${id} in the database`);\r\n\r\n    // Check if user exists\r\n    const user = await this.getById(id);\r\n\r\n    // Throw an exception if user is not found\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Update the user\r\n    user.isLoggedIn = loggedIn;\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the user was not updated\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to Login user');\r\n\r\n    // Return the updated user\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Updates the name of a user.\r\n   * @param id - The ID of the user.\r\n   * @param name - The new name to set.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async updateUsername(id: string, name: string): Promise<UserType> {\r\n    this.logger.log(`Updating username of user with ID ${id} in the database`);\r\n\r\n    // Check if user exists\r\n    const user = await this.getById(id);\r\n\r\n    // Throw an exception if user is not found\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Update the user\r\n    user.username = name;\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the user was not updated\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Updates the password of a user.\r\n   * @param id - The ID of the user.\r\n   * @param password - The new password to set.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async updatePassword(id: string, password: string): Promise<UserType> {\r\n    this.logger.log(`Updating password of user with ID ${id} in the database`);\r\n\r\n    // Check if user exists\r\n    const user = await this.getById(id);\r\n\r\n    // Throw an exception if user is not found\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Update the user\r\n    user.password = password;\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the user was not updated\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Updates the email of a user.\r\n   * @param id - The ID of the user.\r\n   * @param email - The new email to set.\r\n   * @param setUnverified - Whether to set the email as unverified.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async updateEmail(id: string, email: string, setUnverified = false): Promise<UserType> {\r\n    this.logger.log(`Updating email of user with ID ${id} in the database`);\r\n\r\n    // Check if user exists\r\n    const user = await this.getById(id);\r\n\r\n    // Throw an exception if user is not found\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Update the user\r\n    user.email = email;\r\n    user.isVerified = !setUnverified;\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the user was not updated\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Updates the country of a user.\r\n   * @param id - The ID of the user.\r\n   * @param country - The new country to set.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `InternalServerErrorException` Throws an InternalServerErrorException if the update fails.\r\n   */\r\n  public async updateCountry(id: string, country: string): Promise<UserType> {\r\n    this.logger.log(`Updating country of user with ID ${id} in the database`);\r\n\r\n    // Check if user exists\r\n    const user = await this.getById(id);\r\n\r\n    // Throw an exception if user is not found\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Update the user\r\n    user.country = country;\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the user was not updated\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Updates the verification token of a user.\r\n   * @param id - The ID of the user.\r\n   * @param token - The new verification token to set.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async updateVerificationToken(id: string, token: string): Promise<UserType> {\r\n    this.logger.log(`Updating verification token of user with ID ${id} in the database`);\r\n\r\n    // Check if user exists\r\n    const user = await this.getById(id);\r\n\r\n    // Throw an exception if user is not found\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Update the user\r\n    user.verificationToken = token;\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the user was not updated\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Updates the tags of a user.\r\n   * @param id - The ID of the user.\r\n   * @param tagsIds - The IDs of the new tags to set.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async updateUserTags(id: string, tagsIds: number[]): Promise<UserType> {\r\n    this.logger.log(`Updating tags of user with ID ${id} in the database`);\r\n\r\n    // Get the user by ID\r\n    const user = await this.getById(id);\r\n\r\n    // Throw an exception if user is not found\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Fetch the GameTag objects based on the tagIds\r\n    const tags = await this.gameTag.getByIds(tagsIds);\r\n\r\n    // Save the updated user entity\r\n    user.tags = tags;\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the user was not updated\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user entity\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Adds items to the user's library.\r\n   * @param id - The ID of the user.\r\n   * @param itemsIds - An array of item IDs to add to the library.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async addItemsToLibrary(id: string, itemsIds: number[]): Promise<UserType> {\r\n    this.logger.log(`Adding items to library of user with ID ${id} in the database`);\r\n\r\n    // Get the user by ID\r\n    const user = await this.getById(id);\r\n\r\n    // Throw an exception if user is not found\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Create LibraryItem instances for each item ID\r\n    const newItems = itemsIds.map((itemId) => new LibraryItem(itemId));\r\n\r\n    // Add new items to the user's library\r\n    user.library.push(...newItems);\r\n\r\n    // Remove added items from wishlist if they exist\r\n    const newItemsIds = newItems.map((item) => item.id);\r\n    user.cart = user.cart.filter((item) => !newItemsIds.includes(item.id));\r\n    user.wishlist = user.wishlist.filter((item) => !newItemsIds.includes(item.id));\r\n\r\n    // Save the updated user entity\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the user was not updated\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Removes items from the user's library.\r\n   * @param id - The ID of the user.\r\n   * @param itemsIds - An array of item IDs to remove from the library.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` Throws a NotFoundException if the user is not found.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async removeItemsFromLibrary(id: string, itemsIds: number[]): Promise<UserType> {\r\n    this.logger.log(`Removing items from library of user with ID ${id} in the database`);\r\n\r\n    // Get the user by ID\r\n    const user = await this.getById(id);\r\n\r\n    // Throw an exception if user is not found\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Filter out items with IDs included in the provided itemIds array\r\n    const userItemsIds = user.library.map((item) => item.id);\r\n\r\n    // Throw an exception if any of the provided item IDs do not exist in the user's library\r\n    const nonExistingItems = itemsIds.filter((itemId) => !userItemsIds.includes(itemId));\r\n    if (nonExistingItems.length > 0) {\r\n      this.logger.error(`Items with IDs ${nonExistingItems.join(', ')} do not exist in the user's library`);\r\n      throw new NotFoundException(`Items with IDs ${nonExistingItems.join(', ')} do not exist in the user's library`);\r\n    }\r\n\r\n    // Remove items from the user's library based on their IDs\r\n    user.library = user.library.filter((item) => !itemsIds.includes(item.id));\r\n\r\n    // Save the updated user entity\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the user was not updated\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Clears the user's library.\r\n   * @param id - The ID of the user.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async clearLibrary(id: string): Promise<UserType> {\r\n    this.logger.log(`Clearing library of user with ID ${id} in the database`);\r\n\r\n    // Get the user by ID\r\n    const user = await this.getById(id);\r\n\r\n    // Check if user exists\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Clear the user's library\r\n    user.library = [];\r\n\r\n    // Save the updated user entity\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the update fails\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Adds items to the user's wishlist.\r\n   * @param id - The ID of the user.\r\n   * @param itemsIds - An array of item IDs to add to the wishlist.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async addItemsToWishlist(id: string, itemsIds: number[]): Promise<UserType> {\r\n    this.logger.log(`Adding items to wishlist of user with ID ${id} in the database`);\r\n\r\n    // Get the user by ID\r\n    const user = await this.getById(id);\r\n\r\n    // Check if user exists\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Create WishlistItem instances for each item ID\r\n    const newItems = itemsIds.map((itemId) => new WishlistItem(itemId));\r\n\r\n    // Add the new items to the user's wishlist\r\n    user.wishlist.push(...newItems);\r\n\r\n    // Save the updated user entity\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the update fails\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user entity\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Removes items from the user's wishlist.\r\n   * @param id - The ID of the user.\r\n   * @param itemsIds - An array of item IDs to remove from the wishlist.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async removeItemsFromWishlist(id: string, itemsIds: number[]): Promise<UserType> {\r\n    this.logger.log(`Removing items from wishlist of user with ID ${id} in the database`);\r\n\r\n    // Get the user by ID\r\n    const user = await this.getById(id);\r\n\r\n    // Check if user exists\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Filter out items with IDs included in the provided itemIds array\r\n    const nonExistingItems = itemsIds.filter((itemId) => !user.wishlist.map((item) => item.id).includes(itemId));\r\n    if (nonExistingItems.length > 0) {\r\n      this.logger.error(`Items with IDs ${nonExistingItems.join(', ')} do not exist in the user's wishlist`);\r\n      throw new NotFoundException(`Items with IDs ${nonExistingItems.join(', ')} do not exist in the user's wishlist`);\r\n    }\r\n\r\n    // Remove items from the user's wishlist based on their IDs\r\n    user.wishlist = user.wishlist.filter((item) => !itemsIds.includes(item.id));\r\n\r\n    // Save the updated user entity\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the update fails\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user entity\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Clears the user's wishlist.\r\n   * @param id - The ID of the user.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async clearWishlist(id: string): Promise<UserType> {\r\n    this.logger.log(`Clearing wishlist of user with ID ${id} in the database`);\r\n\r\n    // Get the user by ID\r\n    const user = await this.getById(id);\r\n\r\n    // Check if user exists\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Clear the user's wishlist\r\n    user.wishlist = [];\r\n\r\n    // Save the updated user entity\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the update fails\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user entity\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Adds items to the user's cart.\r\n   * @param id - The ID of the user.\r\n   * @param itemsIds - An array of item IDs to add to the cart.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async addItemsToCart(id: string, itemsIds: number[]): Promise<UserType> {\r\n    this.logger.log(`Adding items to cart of user with ID ${id} in the database`);\r\n\r\n    // Get the user by ID\r\n    const user = await this.getById(id);\r\n\r\n    // Check if user exists\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Create CartItem instances for each item ID\r\n    const newItems = itemsIds.map((itemId) => new CartItem(itemId));\r\n\r\n    // Add the new items to the user's cart\r\n    user.cart.push(...newItems);\r\n\r\n    // Save the updated user entity\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the update fails\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user entity\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Removes items from the user's cart.\r\n   * @param id - The ID of the user.\r\n   * @param itemsIds - An array of item IDs to remove from the cart.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async removeItemsFromCart(id: string, itemsIds: number[]): Promise<UserType> {\r\n    this.logger.log(`Removing items from cart of user with ID ${id} in the database`);\r\n\r\n    // Get the user by ID\r\n    const user = await this.getById(id);\r\n\r\n    // Check if user exists\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Filter out items with IDs included in the provided itemIds array\r\n    const cartItemsIds = user.cart.map((item) => item.id);\r\n\r\n    // Throw an exception if any of the provided item IDs do not exist in the user's cart\r\n    const nonExistingItems = itemsIds.filter((itemId) => !cartItemsIds.includes(itemId));\r\n    if (nonExistingItems.length > 0) {\r\n      this.logger.error(`Items with IDs ${nonExistingItems.join(', ')} do not exist in the user's cart`);\r\n      throw new NotFoundException(`Items with IDs ${nonExistingItems.join(', ')} do not exist in the user's cart`);\r\n    }\r\n\r\n    // Remove items from the user's cart based on their IDs\r\n    user.cart = user.cart.filter((item) => !itemsIds.includes(item.id));\r\n\r\n    // Save the updated user entity\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the update fails\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user entity\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Clears the user's cart.\r\n   * @param id - The ID of the user.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async clearCart(id: string): Promise<UserType> {\r\n    this.logger.log(`Clearing cart of user with ID ${id} in the database`);\r\n\r\n    // Get the user by ID\r\n    const user = await this.getById(id);\r\n\r\n    // Check if user exists\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Clear the user's cart\r\n    user.cart = [];\r\n\r\n    // Save the updated user entity\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the update fails\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user entity\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Updates the avatar of a user.\r\n   * @param id - The ID of the user.\r\n   * @param avatarId - The new avatar ID to set.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async updateAvatar(id: string, avatarId: string): Promise<UserType> {\r\n    this.logger.log(`Updating avatar of user with ID ${id} in the database`);\r\n\r\n    // Check if user exists\r\n    const user = await this.getById(id);\r\n\r\n    // Check if user exists\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Update the user\r\n    user.profilePicture = avatarId;\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the update fails\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Removes the avatar of a user.\r\n   * @param id - The ID of the user.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async removeAvatar(id: string): Promise<UserType> {\r\n    this.logger.log(`Removing avatar of user with ID ${id} in the database`);\r\n\r\n    // Check if user exists\r\n    const user = await this.getById(id);\r\n\r\n    // Check if user exists\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Update the user\r\n    user.profilePicture = null;\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the update fails\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Updates the isVerified status of a user.\r\n   * @param id - The ID of the user.\r\n   * @return A Promise that resolves to the updated user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `BadRequestException` if the user is already verified.\r\n   * @throws `InternalServerErrorException` if the update fails.\r\n   */\r\n  public async verify(id: string): Promise<UserType> {\r\n    this.logger.log(`Verifying user with ID ${id} in the database`);\r\n\r\n    // Check if user exists\r\n    const user = await this.getById(id);\r\n\r\n    // Check if user exists\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Throw an exception if user is already verified\r\n    if (user.isVerified) throw new BadRequestException('Email is already verified');\r\n\r\n    // Update the user verification status\r\n    user.isVerified = true;\r\n    user.verificationToken = null;\r\n    const updatedUser = await this.userRepository.save(user);\r\n\r\n    // Throw an exception if the update fails\r\n    if (!updatedUser) throw new InternalServerErrorException('Failed to update user');\r\n\r\n    // Return the updated user\r\n    return updatedUser;\r\n  }\r\n\r\n  /**\r\n   * Removes a user by their ID.\r\n   * @param id - The ID of the user to be removed.\r\n   * @return A Promise that resolves to the removed user entity.\r\n   * @throws `NotFoundException` if the user is not found.\r\n   * @throws `InternalServerErrorException` if the removal fails.\r\n   */\r\n  public async remove(id: string): Promise<UserType> {\r\n    this.logger.log(`Removing user with ID ${id} from the database`);\r\n\r\n    // Check if user exists\r\n    const user = await this.getById(id);\r\n\r\n    // Check if user exists\r\n    if (!user) throw new NotFoundException('User not found');\r\n\r\n    // Remove the user\r\n    const removedUser = await this.userRepository.remove(user);\r\n\r\n    // Throw an exception if the removal fails\r\n    if (!removedUser) throw new InternalServerErrorException('Failed to remove user');\r\n\r\n    // Return the removed user\r\n    return removedUser;\r\n  }\r\n\r\n  /**\r\n   * Removes all users from the database.\r\n   * @return {Promise<void>} A Promise that resolves when the removal is successful.\r\n   * @throws `InternalServerErrorException` if the removal fails.\r\n   */\r\n  public async removeAll(): Promise<void> {\r\n    this.logger.log('Removing all users from the database');\r\n\r\n    // Remove all users\r\n    const result = await this.userRepository.delete({});\r\n\r\n    // Throw an exception if the removal fails\r\n    if (!result) throw new InternalServerErrorException('Failed to remove users');\r\n  }\r\n}\r\n"],"names":["UsersService","constructor","logger","userRepository","gameTag","relations","tags","getAll","orderBy","order","log","users","find","getById","id","reviews","user","findOne","where","getByUsername","username","getByEmail","email","getByEmailOrUsername","emailOrUsername","getByVerificationToken","token","verificationToken","getByPhoneNumber","phoneNumber","NotFoundException","getUsersPaginated","page","limit","searchQuery","ILike","orderOptions","country","isVerified","isAdmin","createdAt","items","total","findAndCount","skip","Math","max","take","totalPages","ceil","create","existingUser","ConflictException","newUser","User","password","createdUser","save","InternalServerErrorException","update","attrs","Object","assign","updatedUser","setLoginStatus","loggedIn","isLoggedIn","updateUsername","name","updatePassword","updateEmail","setUnverified","updateCountry","updateVerificationToken","updateUserTags","tagsIds","getByIds","addItemsToLibrary","itemsIds","newItems","map","itemId","LibraryItem","library","push","newItemsIds","item","cart","filter","includes","wishlist","removeItemsFromLibrary","userItemsIds","nonExistingItems","length","error","join","clearLibrary","addItemsToWishlist","WishlistItem","removeItemsFromWishlist","clearWishlist","addItemsToCart","CartItem","removeItemsFromCart","cartItemsIds","clearCart","updateAvatar","avatarId","profilePicture","removeAvatar","verify","BadRequestException","remove","removedUser","removeAll","result","delete"],"mappings":"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"}