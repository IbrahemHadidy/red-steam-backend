{"version":3,"sources":["../../../../../src/modules/repositories/sql/companies/companies.service.ts"],"sourcesContent":["// NestJS\r\nimport {\r\n  BadRequestException,\r\n  ConflictException,\r\n  Injectable,\r\n  InternalServerErrorException,\r\n  Logger,\r\n  NotFoundException,\r\n} from '@nestjs/common';\r\n\r\n// TypeORM\r\nimport { InjectRepository } from '@nestjs/typeorm';\r\nimport { FindOptionsWhere, ILike, In, Repository } from 'typeorm';\r\n\r\n// Entities\r\nimport { Developer, Publisher } from '@repositories/sql/companies/company.entity';\r\n\r\n// Types\r\nimport { Developer as DeveloperType, Publisher as PublisherType } from '@repositories/sql/companies/company.entity';\r\n\r\n@Injectable()\r\nexport class CompaniesService {\r\n  constructor(\r\n    private readonly logger: Logger,\r\n\r\n    @InjectRepository(Publisher, 'sql')\r\n    private readonly publisherRepository: Repository<Publisher>,\r\n\r\n    @InjectRepository(Developer, 'sql')\r\n    private readonly developerRepository: Repository<Developer>,\r\n  ) {}\r\n\r\n  /**\r\n   * Retrieves all companies.\r\n   * @param type - The type of the companies (publishers or developers).\r\n   * @returns A list of companies.\r\n   */\r\n  public async getAll(\r\n    sortBy: 'id' | 'name' | 'website',\r\n    sortOrder: 'asc' | 'desc',\r\n    type: 'publishers' | 'developers',\r\n  ): Promise<(PublisherType | DeveloperType)[]> {\r\n    this.logger.log(`Retrieving all ${type.charAt(0).toUpperCase() + type.slice(1)} from the database`);\r\n\r\n    // Get the repository based on the type\r\n    const repository = type === 'publishers' ? this.publisherRepository : this.developerRepository;\r\n\r\n    // Find all companies\r\n    const companies = repository.find({ order: { [sortBy]: sortOrder } });\r\n\r\n    // Return the list of companies\r\n    return companies;\r\n  }\r\n\r\n  /**\r\n   * Retrieves a company by ID.\r\n   * @param id - The ID of the company.\r\n   * @param type - The type of the company (publisher or developer).\r\n   * @returns The retrieved company.\r\n   * @throws `NotFoundException` If the company is not found.\r\n   */\r\n  public async getById(id: number, type: 'publisher' | 'developer'): Promise<DeveloperType | PublisherType> {\r\n    this.logger.log(`Retrieving ${type.charAt(0).toUpperCase() + type.slice(1)} with ID ${id} from the database`);\r\n\r\n    // Get the repository based on the type\r\n    const repository = type === 'publisher' ? this.publisherRepository : this.developerRepository;\r\n\r\n    // Find the company by ID\r\n    const company = await repository.findOne({ where: { id } });\r\n\r\n    // Throw a not found exception if the company is not found\r\n    if (!company) throw new NotFoundException(`${type.charAt(0).toUpperCase() + type.slice(1)} not found`);\r\n\r\n    // Return the company\r\n    return company;\r\n  }\r\n\r\n  /**\r\n   * Retrieves multiple companies by IDs.\r\n   * @param ids - The IDs of the companies.\r\n   * @param type - The type of the companies (publisher or developer).\r\n   * @returns The retrieved companies.\r\n   * @throws `NotFoundException` If any of the companies are not found.\r\n   */\r\n  public async getByIds(ids: number[], type: 'publisher' | 'developer'): Promise<(PublisherType | DeveloperType)[]> {\r\n    this.logger.log(`Retrieving ${type.charAt(0).toUpperCase() + type.slice(1)} with IDs ${ids} from the database`);\r\n\r\n    // Get the repository based on the type\r\n    const repository = type === 'publisher' ? this.publisherRepository : this.developerRepository;\r\n\r\n    // Find the companies by IDs\r\n    const companies = await repository.find({ where: { id: In(ids) } });\r\n\r\n    // Throw a not found exception if any of the companies are not found\r\n    if (companies.length !== ids.length) {\r\n      const missingIds = ids.filter((id) => !companies.some((company) => company.id === id));\r\n      throw new NotFoundException(\r\n        `${type.charAt(0).toUpperCase() + type.slice(1)} not found: ${missingIds.join(', ')}`,\r\n      );\r\n    }\r\n\r\n    // Return the companies\r\n    return companies;\r\n  }\r\n\r\n  /**\r\n   * Retrieves a company by name.\r\n   * @param name - The name of the company.\r\n   * @param type - The type of the company (publisher or developer).\r\n   * @returns The retrieved company.\r\n   * @throws `NotFoundException` If the company is not found.\r\n   */\r\n  public async getByName(name: string, type: 'publisher' | 'developer'): Promise<DeveloperType | PublisherType> {\r\n    this.logger.log(`Retrieving ${type.charAt(0).toUpperCase() + type.slice(1)} with name ${name} from the database`);\r\n\r\n    // Get the repository based on the type\r\n    const repository = type === 'publisher' ? this.publisherRepository : this.developerRepository;\r\n\r\n    // Find the company by name\r\n    const company = await repository.findOne({ where: { name } });\r\n\r\n    // Throw a not found exception if the company is not found\r\n    if (!company) throw new NotFoundException(`${type.charAt(0).toUpperCase() + type.slice(1)} not found`);\r\n    return company;\r\n  }\r\n\r\n  /**\r\n   * Gets paginated companies.\r\n   * @param page - The current page number.\r\n   * @param limit - The number of items per page.\r\n   * @param orderBy - The field to order by.\r\n   * @param order - The order direction.\r\n   * @param type - The type of companies to retrieve\r\n   * @param searchQuery - The search query.\r\n   * @returns A promise that resolves to the paginated companies.\r\n   */\r\n  public async getCompaniesPaginated(\r\n    page: number,\r\n    limit: number,\r\n    orderBy: 'id' | 'name' | 'website',\r\n    order: 'ASC' | 'DESC',\r\n    type: 'publisher' | 'developer',\r\n    searchQuery?: { name?: string; website?: string },\r\n  ): Promise<{ items: (PublisherType | DeveloperType)[]; total: number; totalPages: number }> {\r\n    this.logger.log(`Getting ${type}s paginated: page ${page}, limit ${limit}, order by ${orderBy} ${order}`);\r\n\r\n    // Get the repository based on the type\r\n    const repository = type === 'publisher' ? this.publisherRepository : this.developerRepository;\r\n\r\n    // Build the where clause\r\n    const where: FindOptionsWhere<Publisher | Developer> = {};\r\n    if (searchQuery.name) {\r\n      where.name = ILike(`%${searchQuery.name}%`);\r\n    }\r\n    if (searchQuery.website) {\r\n      where.website = ILike(`%${searchQuery.website}%`);\r\n    }\r\n\r\n    // Find and count the companies\r\n    const [items, total] = await repository.findAndCount({\r\n      where,\r\n      order: { [orderBy]: order },\r\n      skip: Math.max((page - 1) * limit, 0),\r\n      take: limit,\r\n    });\r\n\r\n    // Calculate the total number of pages\r\n    const totalPages = Math.ceil(total / limit);\r\n\r\n    this.logger.log(`Found ${total} ${type}s in the database`);\r\n\r\n    // Return the paginated companies\r\n    return { items, total, totalPages };\r\n  }\r\n\r\n  /**\r\n   * Creates a new company.\r\n   * @param name - The name of the company.\r\n   * @param website - The website of the company.\r\n   * @param type - The type of the company (publisher or developer).\r\n   * @returns The created company.\r\n   * @throws `ConflictException` If the company name or website already exists.\r\n   */\r\n  public async create(\r\n    company: { name: string; website: string },\r\n    type: 'publisher' | 'developer',\r\n  ): Promise<PublisherType | DeveloperType> {\r\n    this.logger.log(`Creating a new ${type.charAt(0).toUpperCase() + type.slice(1)} in the database`);\r\n\r\n    // Check if the company name or website already exists\r\n    await this.checkValueIsUnique('name', company.name, type);\r\n    await this.checkValueIsUnique('website', company.website, type);\r\n\r\n    // Check if the url is valid\r\n    await this.checkValidWebsite(company.website);\r\n\r\n    // Get the repository based on the type\r\n    const repository = type === 'publisher' ? this.publisherRepository : this.developerRepository;\r\n\r\n    // Create and save the new company\r\n    const newCompany = repository.create({ name: company.name, website: company.website });\r\n\r\n    // Save the new company\r\n    if (!newCompany) throw new InternalServerErrorException('Failed to create company');\r\n\r\n    // Return the new company\r\n    return repository.save(newCompany);\r\n  }\r\n\r\n  /**\r\n   * Updates a company.\r\n   * @param id - The ID of the company.\r\n   * @param updateType - The type of the update (name or website).\r\n   * @param value - The new value of the update.\r\n   * @param type - The type of the company (publisher or developer).\r\n   * @returns The updated company.\r\n   * @throws `NotFoundException` If the company is not found.\r\n   * @throws `ConflictException` If the update value already exists.\r\n   * @throws `BadRequestException` If the update value is invalid.\r\n   */\r\n  public async update(\r\n    id: number,\r\n    updateType: 'name' | 'website',\r\n    value: string,\r\n    type: 'publisher' | 'developer',\r\n  ): Promise<PublisherType | DeveloperType> {\r\n    this.logger.log(`Updating ${type.charAt(0).toUpperCase() + type.slice(1)} in the database`);\r\n\r\n    const company = await this.getById(id, type);\r\n\r\n    // Check if the company exists\r\n    await this.checkCompanyExists('id', id, type);\r\n\r\n    // Check if the update value is unique and website is valid\r\n    if (updateType === 'name' && value !== company.name) await this.checkValueIsUnique(updateType, value, type);\r\n    if (updateType === 'website' && value !== company.website) await this.checkValueIsUnique(updateType, value, type);\r\n    if (updateType === 'website') {\r\n      await this.checkValidWebsite(value);\r\n    }\r\n\r\n    // Get the repository based on the type\r\n    const repository = type === 'publisher' ? this.publisherRepository : this.developerRepository;\r\n\r\n    // Update the company\r\n    company[updateType] = value;\r\n\r\n    // Save the updated company\r\n    const updatedCompany = await repository.save(company);\r\n\r\n    // Throw an exception if the company was not updated\r\n    if (!updatedCompany) throw new InternalServerErrorException(`Failed to update ${type} in the database`);\r\n\r\n    // Return the updated company\r\n    return updatedCompany;\r\n  }\r\n\r\n  /**\r\n   * Deletes a company.\r\n   * @param id - The ID of the company.\r\n   * @param type - The type of the company (publisher or developer).\r\n   * @throws `NotFoundException` If the company is not found.\r\n   */\r\n  public async remove(id: number, type: 'publisher' | 'developer'): Promise<void> {\r\n    this.logger.log(`Removing ${type.charAt(0).toUpperCase() + type.slice(1)} from the database`);\r\n\r\n    // Check if company exists\r\n    await this.checkCompanyExists('id', id, type);\r\n\r\n    // Get the repository based on the type\r\n    const repository = type === 'publisher' ? this.publisherRepository : this.developerRepository;\r\n\r\n    // Attempt to delete the company\r\n    const result = await repository.delete(id);\r\n\r\n    // Throw an exception if the company was not deleted\r\n    if (!result.affected) throw new InternalServerErrorException(`Failed to delete ${type} from the database`);\r\n  }\r\n\r\n  /**\r\n   * Removes all companies from the database.\r\n   * @param type - The type of the companies (publishers or developers).\r\n   * @throws `InternalServerErrorException` If the removal fails.\r\n   */\r\n  public async removeAll(type: 'publishers' | 'developers'): Promise<void> {\r\n    this.logger.log(`Removing all ${type.charAt(0).toUpperCase() + type.slice(1)} from the database`);\r\n\r\n    // Get the repository based on the type\r\n    const repository = type === 'publishers' ? this.publisherRepository : this.developerRepository;\r\n\r\n    // Attempt to delete all records\r\n    const result = await repository.delete({});\r\n\r\n    // Throw an exception if the removal fails\r\n    if (result.affected === undefined)\r\n      throw new InternalServerErrorException(`Failed to remove ${type} from the database`);\r\n  }\r\n\r\n  /**\r\n   * Checks if a company with the given property exists.\r\n   * @param checkBy - The property to check (id, name, or website).\r\n   * @param checkValue - The value to check.\r\n   * @param type - The type of the company (publisher or developer).\r\n   * @throws `NotFoundException` If the company is not found.\r\n   */\r\n  private async checkCompanyExists(\r\n    checkBy: 'id' | 'name' | 'website',\r\n    checkValue: number | string,\r\n    type: 'publisher' | 'developer',\r\n  ): Promise<void> {\r\n    // Get the repository based on the type\r\n    const repository = type === 'publisher' ? this.publisherRepository : this.developerRepository;\r\n\r\n    // Check if company exists\r\n    const company = await repository.findOne({ where: { [checkBy]: checkValue } });\r\n\r\n    // Throw a not found exception if company does not exist\r\n    if (!company) throw new NotFoundException(`${type.charAt(0).toUpperCase() + type.slice(1)} not found`);\r\n  }\r\n\r\n  /**\r\n   * Checks if a value is unique.\r\n   * @param updateType - The type of the update (name or website).\r\n   * @param value - The value to check.\r\n   * @param type - The type of the company (publisher or developer).\r\n   * @throws `ConflictException` If the value is not unique.\r\n   */\r\n  private async checkValueIsUnique(\r\n    updateType: 'name' | 'website',\r\n    value: string,\r\n    type: 'publisher' | 'developer',\r\n  ): Promise<void> {\r\n    // Get the repository based on the type\r\n    const repository = type === 'publisher' ? this.publisherRepository : this.developerRepository;\r\n\r\n    // Check if value is unique\r\n    const company = await repository.findOne({ where: { [updateType]: value } });\r\n\r\n    // Throw a conflict exception if value is not unique\r\n    if (company)\r\n      throw new ConflictException(`${type.charAt(0).toUpperCase() + type.slice(1)} ${updateType} already exists`);\r\n  }\r\n\r\n  /**\r\n   * Checks if the website is valid.\r\n   * @param website - The website to check.\r\n   * @throws `BadRequestException` If the website is not valid.\r\n   */\r\n  private async checkValidWebsite(website: string): Promise<void> {\r\n    // Regular expression to match a valid website URL\r\n    const urlRegex = /^https?:\\/\\/[\\w\\-]+(\\.[\\w\\-]+)+[/#?]?.*$/;\r\n\r\n    // Throw a bad request exception if the website is not valid\r\n    if (!website.match(urlRegex)) throw new BadRequestException('Invalid website URL');\r\n  }\r\n}\r\n"],"names":["CompaniesService","constructor","logger","publisherRepository","developerRepository","getAll","sortBy","sortOrder","type","log","charAt","toUpperCase","slice","repository","companies","find","order","getById","id","company","findOne","where","NotFoundException","getByIds","ids","In","length","missingIds","filter","some","join","getByName","name","getCompaniesPaginated","page","limit","orderBy","searchQuery","ILike","website","items","total","findAndCount","skip","Math","max","take","totalPages","ceil","create","checkValueIsUnique","checkValidWebsite","newCompany","InternalServerErrorException","save","update","updateType","value","checkCompanyExists","updatedCompany","remove","result","delete","affected","removeAll","undefined","checkBy","checkValue","ConflictException","urlRegex","match","BadRequestException"],"mappings":"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"}