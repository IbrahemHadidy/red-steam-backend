{"version":3,"sources":["../../../../../src/modules/repositories/sql/reviews/reviews.service.ts"],"sourcesContent":["// NestJS\r\nimport {\r\n  BadRequestException,\r\n  ConflictException,\r\n  Injectable,\r\n  InternalServerErrorException,\r\n  Logger,\r\n  NotFoundException,\r\n} from '@nestjs/common';\r\n\r\n// TypeORM\r\nimport { InjectRepository } from '@nestjs/typeorm';\r\nimport { FindOptionsOrder, FindOptionsRelations, FindOptionsWhere, ILike, Repository } from 'typeorm';\r\n\r\n// Services\r\nimport { GamesService } from '@repositories/sql/games/games.service';\r\nimport { UsersService } from '@repositories/sql/users/users.service';\r\n\r\n// Entities\r\nimport { Review } from '@repositories/sql/reviews/review.entity';\r\n\r\n// Types\r\nimport { Review as ReviewType } from '@repositories/sql/reviews/review.entity';\r\n\r\n@Injectable()\r\nexport class ReviewsService {\r\n  private readonly relations: FindOptionsRelations<Review>;\r\n\r\n  constructor(\r\n    private readonly logger: Logger,\r\n    @InjectRepository(Review, 'sql')\r\n    private readonly reviewRepository: Repository<Review>,\r\n    private readonly gamesService: GamesService,\r\n    private readonly usersService: UsersService,\r\n  ) {\r\n    this.relations = { user: true, game: true };\r\n  }\r\n\r\n  /**\r\n   * Get all reviews with dynamic ordering.\r\n   * @param orderBy - The field to order by.\r\n   * @param order - The order direction.\r\n   * @returns A promise of an array of reviews.\r\n   */\r\n  public async getAll(orderBy: 'date' | 'positive' | 'user' | 'game', order: 'ASC' | 'DESC'): Promise<ReviewType[]> {\r\n    this.logger.log('Getting all reviews');\r\n\r\n    // Build order options\r\n    const orderOptions = this.createOrderOptions(orderBy, order);\r\n\r\n    // Get all reviews\r\n    const reviews = await this.reviewRepository.find({ relations: this.relations, order: orderOptions });\r\n\r\n    // Return reviews\r\n    return reviews;\r\n  }\r\n\r\n  /**\r\n   * Get all positive reviews with dynamic ordering.\r\n   * @param orderBy - The field to order by.\r\n   * @param order - The order direction.\r\n   * @returns A promise of an array of reviews.\r\n   */\r\n  public async getAllPositive(\r\n    orderBy: 'date' | 'positive' | 'user' | 'game',\r\n    order: 'ASC' | 'DESC',\r\n  ): Promise<ReviewType[]> {\r\n    this.logger.log('Getting all positive reviews');\r\n\r\n    // Build order options\r\n    const orderOptions = this.createOrderOptions(orderBy, order);\r\n\r\n    // Get all positive reviews\r\n    const reviews = await this.reviewRepository.find({\r\n      where: { positive: true },\r\n      relations: this.relations,\r\n      order: orderOptions,\r\n    });\r\n\r\n    // Return reviews\r\n    return reviews;\r\n  }\r\n\r\n  /**\r\n   * Get all negative reviews with dynamic ordering.\r\n   * @param orderBy - The field to order by.\r\n   * @param order - The order direction.\r\n   * @returns A promise of an array of reviews.\r\n   */\r\n  public async getAllNegative(\r\n    orderBy: 'date' | 'positive' | 'user' | 'game',\r\n    order: 'ASC' | 'DESC',\r\n  ): Promise<ReviewType[]> {\r\n    this.logger.log('Getting all negative reviews');\r\n\r\n    // Build order options\r\n    const orderOptions = this.createOrderOptions(orderBy, order);\r\n\r\n    // Get all negative reviews\r\n    const reviews = await this.reviewRepository.find({\r\n      where: { positive: false },\r\n      relations: this.relations,\r\n      order: orderOptions,\r\n    });\r\n\r\n    // Return reviews\r\n    return reviews;\r\n  }\r\n\r\n  /**\r\n   * Get a review by ID.\r\n   * @param id - The ID of the review.\r\n   * @returns A promise of the review.\r\n   */\r\n  public async getById(id: number): Promise<ReviewType> {\r\n    this.logger.log(`Getting review with ID ${id}`);\r\n\r\n    // Get the review by ID\r\n    const review = await this.reviewRepository.findOne({\r\n      where: { id },\r\n      relations: this.relations,\r\n    });\r\n\r\n    // Throw a not found exception if the review is not found\r\n    if (!review) throw new NotFoundException(`Review with ID ${id} not found`);\r\n\r\n    // Return the review\r\n    return review;\r\n  }\r\n\r\n  /**\r\n   * Get reviews by game ID with dynamic ordering.\r\n   * @param id - The game ID.\r\n   * @param filter - The filter to apply.\r\n   * @param sort - The sort order.\r\n   * @param pagination - The pagination options.\r\n   * @returns A promise of an array of reviews.\r\n   */\r\n  public async getByGameId(\r\n    id: number,\r\n    filter: 'positive' | 'negative' | 'all',\r\n    sort: 'newest' | 'oldest',\r\n    pagination?: { offset: number; limit: number },\r\n  ): Promise<ReviewType[]> {\r\n    this.logger.log(`Getting reviews for game with ID ${id}`);\r\n\r\n    // Create the where condition based on the filter\r\n    const whereCondition: FindOptionsWhere<ReviewType> = { game: { id } };\r\n\r\n    // Add the filter to the where condition\r\n    if (filter === 'positive') {\r\n      whereCondition.positive = true;\r\n    } else if (filter === 'negative') {\r\n      whereCondition.positive = false;\r\n    } else if (filter === 'all') {\r\n      // Do nothing\r\n    }\r\n\r\n    // Add the sort to the where condition\r\n    const reviews = await this.reviewRepository.find({\r\n      where: whereCondition,\r\n      relations: { game: true, user: true },\r\n      order: { date: sort === 'newest' ? 'DESC' : 'ASC' },\r\n      skip: pagination.offset,\r\n      take: pagination.limit,\r\n    });\r\n\r\n    // Return reviews\r\n    return reviews;\r\n  }\r\n\r\n  /**\r\n   * Get reviews by user ID with dynamic ordering.\r\n   * @param id - The user ID.\r\n   * @param filter - The filter to apply.\r\n   * @param sort - The sort order.\r\n   * @param pagination - The pagination options.\r\n   * @returns A promise of an array of reviews.\r\n   */\r\n  public async getByUserId(\r\n    id: string,\r\n    filter: 'positive' | 'negative' | 'all',\r\n    sort: 'newest' | 'oldest',\r\n    pagination?: { offset: number; limit: number },\r\n  ): Promise<ReviewType[]> {\r\n    this.logger.log(`Getting reviews for user with ID ${id}`);\r\n\r\n    // Create the where condition based on the filter\r\n    const whereCondition: FindOptionsWhere<Review> = { user: { id } };\r\n\r\n    // Add the filter to the where condition\r\n    if (filter === 'positive') {\r\n      whereCondition.positive = true;\r\n    } else if (filter === 'negative') {\r\n      whereCondition.positive = false;\r\n    }\r\n\r\n    // Add the sort to the where condition\r\n    const reviews = await this.reviewRepository.find({\r\n      where: whereCondition,\r\n      relations: { user: true },\r\n      order: { date: sort === 'newest' ? 'DESC' : 'ASC' },\r\n      skip: pagination.offset,\r\n      take: pagination.limit,\r\n    });\r\n\r\n    // Return reviews\r\n    return reviews;\r\n  }\r\n\r\n  /**\r\n   * Gets paginated reviews.\r\n   * @param page - The current page number.\r\n   * @param limit - The number of items per page.\r\n   * @param orderBy - The field to order by.\r\n   * @param order - The order direction.\r\n   * @param searchQuery - The search query.\r\n   * @returns A promise that resolves to the paginated reviews.\r\n   */\r\n  public async getReviewsPaginated(\r\n    page: number,\r\n    limit: number,\r\n    orderBy: 'id' | 'username' | 'gameName' | 'content' | 'rating',\r\n    order: 'ASC' | 'DESC',\r\n    searchQuery?: { username?: string; gameName?: string; content?: string },\r\n  ): Promise<{ items: ReviewType[]; total: number; totalPages: number }> {\r\n    this.logger.log(`Getting reviews paginated: page ${page}, limit ${limit}, order by ${orderBy} ${order}`);\r\n\r\n    // Create the where condition\r\n    const where: FindOptionsWhere<ReviewType> = {};\r\n    if (searchQuery?.username) {\r\n      where.user = { username: ILike(`%${searchQuery.username}%`) };\r\n    }\r\n    if (searchQuery?.gameName) {\r\n      where.game = { name: ILike(`%${searchQuery.gameName}%`) };\r\n    }\r\n    if (searchQuery?.content) {\r\n      where.content = ILike(`%${searchQuery.content}%`);\r\n    }\r\n\r\n    // Create the order options\r\n    const orderOptions: FindOptionsOrder<ReviewType> = {};\r\n    if (orderBy === 'id') {\r\n      orderOptions.id = order;\r\n    } else if (orderBy === 'username') {\r\n      orderOptions.user = { username: order };\r\n    } else if (orderBy === 'gameName') {\r\n      orderOptions.game = { name: order };\r\n    } else if (orderBy === 'content') {\r\n      orderOptions.content = order;\r\n    } else if (orderBy === 'rating') {\r\n      orderOptions.positive = order;\r\n    }\r\n\r\n    // Get the reviews\r\n    const [items, total] = await this.reviewRepository.findAndCount({\r\n      where,\r\n      relations: this.relations,\r\n      order: orderOptions,\r\n      skip: Math.max((page - 1) * limit, 0),\r\n      take: limit,\r\n    });\r\n\r\n    // Calculate the total number of pages\r\n    const totalPages = Math.ceil(total / limit);\r\n\r\n    // Return the paginated reviews and total number of pages\r\n    return { items, total, totalPages };\r\n  }\r\n\r\n  /**\r\n   * Check if a user has reviewed a game.\r\n   * @param userId - The ID of the user.\r\n   * @param gameId - The ID of the game.\r\n   * @returns A promise of a boolean indicating if the user has reviewed the game.\r\n   */\r\n  public async hasUserReviewedGame(userId: string, gameId: number): Promise<{ reviewed: boolean; review?: Review }> {\r\n    this.logger.log(`Checking if user with ID ${userId} has reviewed game with ID ${gameId}`);\r\n\r\n    // Check if the review exists\r\n    const review = await this.reviewRepository.findOne({\r\n      where: {\r\n        user: { id: userId },\r\n        game: { id: gameId },\r\n      },\r\n      relations: { user: true, game: true },\r\n    });\r\n\r\n    // Return true if the review exists\r\n    return { reviewed: !!review, review };\r\n  }\r\n\r\n  /**\r\n   * Create a new review.\r\n   * @param review - The review to create.\r\n   * @returns A promise of the created review.\r\n   * @throws `BadRequestException` if the game has already been reviewed by the user.\r\n   */\r\n  public async create(review: { userId: string; gameId: number; positive: boolean; content: string }): Promise<Review> {\r\n    this.logger.log(`Creating review for game with ID ${review.gameId}`);\r\n\r\n    // Validate the content\r\n    await this.validateContent(review.content);\r\n\r\n    // Get the game and user\r\n    const game = await this.gamesService.getById(review.gameId);\r\n    const user = await this.usersService.getById(review.userId);\r\n\r\n    // Check if the game has already been reviewed\r\n    const existingReview = await this.reviewRepository.findOne({\r\n      where: { user: { id: review.userId }, game: { id: review.gameId } },\r\n      relations: { user: true, game: true },\r\n    });\r\n    if (existingReview) throw new ConflictException('You have already reviewed this game');\r\n\r\n    // Create and save the new review\r\n    const newReview = this.reviewRepository.create({\r\n      positive: review.positive,\r\n      content: review.content,\r\n    });\r\n    newReview.user = user;\r\n    newReview.game = game;\r\n    const result = this.reviewRepository.save(newReview);\r\n\r\n    // If the review was not created, throw an exception\r\n    if (!result) throw new InternalServerErrorException(`Failed to create review for game ${review.gameId}`);\r\n\r\n    // Return the review\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Update a review.\r\n   * @param id - The ID of the review to update.\r\n   * @param review - The updated review.\r\n   * @returns A promise of the updated review.\r\n   * @throws `NotFoundException` if the review does not exist.\r\n   */\r\n  public async update(id: number, review: { positive: boolean; content: string }): Promise<ReviewType> {\r\n    this.logger.log(`Updating review with ID ${id}`);\r\n\r\n    // Check if the review exists\r\n    const existingReview = await this.reviewRepository.findOne({\r\n      where: { id },\r\n      relations: { user: true, game: true },\r\n    });\r\n    if (!existingReview) throw new NotFoundException(`Review with ID ${id} not found`);\r\n\r\n    // Validate the content\r\n    await this.validateContent(review.content);\r\n\r\n    // Update the review\r\n    existingReview.date = new Date();\r\n    existingReview.positive = review.positive;\r\n    existingReview.content = review.content;\r\n\r\n    // Save the review\r\n    const result = this.reviewRepository.save(existingReview);\r\n\r\n    // If the review was not updated, throw an exception\r\n    if (!result) throw new InternalServerErrorException(`Failed to update review with ID ${id}`);\r\n\r\n    // Return the review\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Delete a review.\r\n   * @param id - The ID of the review to delete.\r\n   * @returns A promise of the deleted review.\r\n   * @throws `NotFoundException` if the review does not exist.\r\n   */\r\n  public async remove(id: number): Promise<ReviewType> {\r\n    this.logger.log(`Deleting review with ID ${id}`);\r\n\r\n    // Check if the review exists\r\n    const existingReview = await this.reviewRepository.findOne({\r\n      where: { id },\r\n      relations: { user: true, game: true },\r\n    });\r\n    if (!existingReview) throw new NotFoundException(`Review with ID ${id} not found`);\r\n\r\n    // Delete the review\r\n    const result = await this.reviewRepository.delete({ id });\r\n\r\n    // If the review was not deleted, throw an exception\r\n    if (!result.affected) throw new InternalServerErrorException('Failed to delete review');\r\n\r\n    // Return the deleted review\r\n    return existingReview;\r\n  }\r\n\r\n  /**\r\n   * Delete all user reviews.\r\n   * @param userId - The ID of the user to delete reviews for.\r\n   * @throws `NotFoundException` if the user does not exist.\r\n   * @throws `InternalServerErrorException` if the deletion fails.\r\n   */\r\n  public async removeAllUserReviews(userId: string): Promise<void> {\r\n    this.logger.log(`Deleting all reviews for user with ID ${userId}`);\r\n\r\n    // Check if the user exists\r\n    const user = await this.usersService.getById(userId);\r\n\r\n    // If the user does not exist, throw an exception\r\n    if (!user) throw new NotFoundException(`User with ID ${userId} not found`);\r\n\r\n    // Delete the reviews\r\n    const result = await this.reviewRepository.delete({ user: { id: userId } });\r\n\r\n    // If the reviews were not deleted, throw an exception\r\n    if (result.affected === undefined) throw new InternalServerErrorException('Failed to delete reviews');\r\n  }\r\n\r\n  /**\r\n   * Delete all game reviews.\r\n   * @param gameId - The ID of the game to delete reviews for.\r\n   * @throws `InternalServerErrorException` if the deletion fails.\r\n   */\r\n  public async removeAllGameReviews(gameId: number): Promise<void> {\r\n    this.logger.log(`Deleting all reviews for game with ID ${gameId}`);\r\n\r\n    // Check if the game exists\r\n    await this.gamesService.getById(gameId);\r\n\r\n    // Delete the reviews\r\n    const result = await this.reviewRepository.delete({ game: { id: gameId } });\r\n\r\n    // If the reviews were not deleted, throw an exception\r\n    if (result.affected === undefined) throw new InternalServerErrorException('Failed to delete reviews');\r\n  }\r\n\r\n  /**\r\n   * Delete all reviews.\r\n   * @throws `InternalServerErrorException` if the deletion fails.\r\n   */\r\n  public async removeAll(): Promise<void> {\r\n    this.logger.log('Deleting all reviews');\r\n\r\n    // Delete the reviews\r\n    const result = await this.reviewRepository.delete({});\r\n\r\n    // If the reviews were not deleted, throw an exception\r\n    if (result.affected === undefined) throw new InternalServerErrorException('Failed to delete reviews');\r\n  }\r\n\r\n  /**\r\n   * Create a query builder with dynamic ordering.\r\n   * @param orderBy - The field to order by.\r\n   * @param order - The order direction.\r\n   * @returns A query builder with dynamic ordering.\r\n   */\r\n  private createOrderOptions(\r\n    orderBy: 'date' | 'positive' | 'user' | 'game',\r\n    order: 'ASC' | 'DESC',\r\n  ): FindOptionsOrder<ReviewType> {\r\n    // Build order options\r\n    const orderOptions: FindOptionsOrder<ReviewType> = {};\r\n    if (orderBy === 'user') {\r\n      orderOptions['user.username'] = order;\r\n    } else if (orderBy === 'game') {\r\n      orderOptions['game.name'] = order;\r\n    } else {\r\n      orderOptions[orderBy] = order;\r\n    }\r\n\r\n    // Return order options\r\n    return orderOptions;\r\n  }\r\n\r\n  /**\r\n   * Validate the content of a review.\r\n   * @param content - The content of the review.\r\n   * @throws `BadRequestException` if the content is invalid.\r\n   */\r\n  private async validateContent(content: string) {\r\n    // If content is more than 500 characters or less than 10 characters, throw a bad request exception\r\n    if (content.length > 500) throw new BadRequestException('Review content must be less than 500 characters long');\r\n    if (content.length < 10) throw new BadRequestException('Review content must be at least 10 characters long');\r\n  }\r\n}\r\n"],"names":["ReviewsService","constructor","logger","reviewRepository","gamesService","usersService","relations","user","game","getAll","orderBy","order","log","orderOptions","createOrderOptions","reviews","find","getAllPositive","where","positive","getAllNegative","getById","id","review","findOne","NotFoundException","getByGameId","filter","sort","pagination","whereCondition","date","skip","offset","take","limit","getByUserId","getReviewsPaginated","page","searchQuery","username","ILike","gameName","name","content","items","total","findAndCount","Math","max","totalPages","ceil","hasUserReviewedGame","userId","gameId","reviewed","create","validateContent","existingReview","ConflictException","newReview","result","save","InternalServerErrorException","update","Date","remove","delete","affected","removeAllUserReviews","undefined","removeAllGameReviews","removeAll","length","BadRequestException"],"mappings":"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"}