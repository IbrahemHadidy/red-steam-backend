{"version":3,"sources":["../../../../../src/modules/repositories/sql/games-features/games-features.service.ts"],"sourcesContent":["// NestJS\r\nimport { ConflictException, Injectable, InternalServerErrorException, Logger, NotFoundException } from '@nestjs/common';\r\n\r\n// TypeORM\r\nimport { InjectRepository } from '@nestjs/typeorm';\r\nimport { FindOptionsWhere, ILike, In, Repository } from 'typeorm';\r\n\r\n// Entities\r\nimport { GameFeature } from '@repositories/sql/games-features/game-feature.entity';\r\n\r\n// Types\r\nimport { GameFeature as GameFeatureType } from '@repositories/sql/games-features/game-feature.entity';\r\n\r\n@Injectable()\r\nexport class GamesFeaturesService {\r\n  constructor(\r\n    private readonly logger: Logger,\r\n    @InjectRepository(GameFeature, 'sql')\r\n    private readonly gameFeatureRepository: Repository<GameFeature>,\r\n  ) {}\r\n\r\n  /**\r\n   * Gets all features.\r\n   * @returns A promise that resolves to an array of features.\r\n   */\r\n  public async getAll(orderBy: 'id' | 'name', order: 'ASC' | 'DESC'): Promise<GameFeatureType[]> {\r\n    this.logger.log('Getting all features');\r\n\r\n    // Get all features\r\n    const features = await this.gameFeatureRepository.find({ order: { [orderBy]: order } });\r\n\r\n    // Return the features\r\n    return features;\r\n  }\r\n\r\n  /**\r\n   * Gets a feature by its ID.\r\n   * @param id - The ID of the feature to retrieve.\r\n   * @returns A promise that resolves to the retrieved feature.\r\n   * @throws `NotFoundException` If the feature is not found.\r\n   */\r\n  public async getById(id: number): Promise<GameFeatureType> {\r\n    this.logger.log(`Getting feature with ID ${id}`);\r\n\r\n    // Get the feature by its ID\r\n    const feature = await this.gameFeatureRepository.findOne({ where: { id } });\r\n\r\n    // Throw a NotFoundException if the feature is not found\r\n    if (!feature) throw new NotFoundException(`Feature with ID ${id} not found`);\r\n\r\n    // return the feature\r\n    return feature;\r\n  }\r\n\r\n  /**\r\n   * Gets features by their IDs.\r\n   * @param ids - The IDs of the features to retrieve.\r\n   * @returns A promise that resolves to an array of features.\r\n   * @throws `NotFoundException` If any of the features are not found.\r\n   */\r\n  public async getByIds(ids: number[]): Promise<GameFeatureType[]> {\r\n    this.logger.log(`Getting features with IDs ${ids}`);\r\n\r\n    // Get the features by their IDs\r\n    const features = await this.gameFeatureRepository.find({ where: { id: In(ids) } });\r\n\r\n    // if any feature is not found throw an error\r\n    if (features.length < ids.length) {\r\n      const missingIds = ids.filter((id) => !features.some((feature) => feature.id === id));\r\n      throw new NotFoundException(`Features with IDs ${missingIds} not found`);\r\n    }\r\n\r\n    // return the features\r\n    return features;\r\n  }\r\n\r\n  /**\r\n   * Gets a feature by its name.\r\n   * @param name - The name of the feature to retrieve.\r\n   * @returns A promise that resolves to the retrieved feature.\r\n   * @throws `NotFoundException` If the feature is not found.\r\n   */\r\n  public async getByName(name: string): Promise<GameFeatureType> {\r\n    this.logger.log(`Getting feature with name ${name}`);\r\n\r\n    // Get the feature by its name\r\n    const feature = await this.gameFeatureRepository.findOne({ where: { name } });\r\n\r\n    // Throw a NotFoundException if the feature is not found\r\n    if (!feature) throw new NotFoundException(`Feature with name ${name} not found`);\r\n\r\n    // return the feature\r\n    return feature;\r\n  }\r\n\r\n  /**\r\n   * Gets paginated features.\r\n   * @param page - The current page number.\r\n   * @param limit - The number of items per page.\r\n   * @param orderBy - The field to order by.\r\n   * @param order - The order direction.\r\n   * @param searchQuery - The search query.\r\n   * @returns A promise that resolves to the paginated features.\r\n   */\r\n  public async getFeaturesPaginated(\r\n    page: number,\r\n    limit: number,\r\n    orderBy: 'id' | 'name',\r\n    order: 'ASC' | 'DESC',\r\n    searchQuery?: { name?: string },\r\n  ): Promise<{ items: GameFeatureType[]; total: number; totalPages: number }> {\r\n    this.logger.log(`Getting features paginated: page ${page}, limit ${limit}, order by ${orderBy} ${order}`);\r\n\r\n    // Create a where clause based on the search query\r\n    const where: FindOptionsWhere<GameFeatureType> = {};\r\n    if (searchQuery?.name) {\r\n      where.name = ILike(`%${searchQuery.name}%`);\r\n    }\r\n\r\n    // Get the paginated features\r\n    const [items, total] = await this.gameFeatureRepository.findAndCount({\r\n      where,\r\n      order: { [orderBy]: order },\r\n      skip: Math.max((page - 1) * limit, 0),\r\n      take: limit,\r\n    });\r\n\r\n    // Calculate the total number of pages\r\n    const totalPages = Math.ceil(total / limit);\r\n\r\n    // Return the paginated features and total number of pages\r\n    return { items, total, totalPages };\r\n  }\r\n\r\n  /**\r\n   * Creates a new feature.\r\n   * @param feature - An object containing the name and icon of the feature.\r\n   * @returns A promise that resolves to the created feature.\r\n   * @throws `InternalServerErrorException` If the feature could not be created.\r\n   */\r\n  public async create(feature: { name: string; icon: Buffer }): Promise<GameFeatureType> {\r\n    this.logger.log(`Creating feature with name ${feature.name}`);\r\n\r\n    // Check if the feature already exists with the same name\r\n    const existingFeature = await this.gameFeatureRepository.findOne({ where: { name: feature.name } });\r\n    if (existingFeature) throw new ConflictException(`Feature with name ${feature.name} already exists`);\r\n\r\n    // Create the new feature\r\n    const newFeature = this.gameFeatureRepository.create({\r\n      name: feature.name,\r\n      icon: feature.icon,\r\n    });\r\n\r\n    // Save the new feature\r\n    const createdFeature = await this.gameFeatureRepository.save(newFeature);\r\n\r\n    // Throw an InternalServerErrorException if the feature could not be created\r\n    if (!createdFeature) throw new InternalServerErrorException('Failed to create feature');\r\n\r\n    // Return the created feature\r\n    return createdFeature;\r\n  }\r\n\r\n  /**\r\n   * Updates an existing feature.\r\n   * @param id - The ID of the feature to update.\r\n   * @param feature - The updated feature data.\r\n   * @returns A promise that resolves to the updated feature.\r\n   * @throws `NotFoundException` If the feature is not found.\r\n   * @throws `InternalServerErrorException` If no data is provided to update.\r\n   */\r\n  public async update(id: number, feature: { name?: string; icon?: Buffer }): Promise<GameFeatureType> {\r\n    this.logger.log(`Updating feature with ID ${id}`);\r\n\r\n    // Find the existing feature by its ID\r\n    const existingFeature = await this.gameFeatureRepository.findOne({ where: { id } });\r\n\r\n    // Throw a NotFoundException if the feature does not exist\r\n    if (!existingFeature) throw new NotFoundException(`Feature with ID ${id} not found`);\r\n\r\n    // Throw an InternalServerErrorException if no data to update\r\n    if (feature.name === undefined && feature.icon === undefined)\r\n      throw new InternalServerErrorException('No valid data provided for updating');\r\n\r\n    // Update the existing feature with the new values\r\n    if (feature.name !== undefined) existingFeature.name = feature.name;\r\n    if (feature.icon !== undefined) existingFeature.icon = feature.icon;\r\n\r\n    // Save the updated feature entity\r\n    const updatedFeature = await this.gameFeatureRepository.save(existingFeature);\r\n\r\n    // Return the updated feature\r\n    return updatedFeature;\r\n  }\r\n\r\n  /**\r\n   * Removes a feature by its ID.\r\n   * @param {number} id - The ID of the feature to remove.\r\n   * @returns A promise that resolves to the removed feature.\r\n   * @throws `NotFoundException` If the feature is not found.\r\n   * @throws `InternalServerErrorException` If the feature could not be removed.\r\n   */\r\n  public async remove(id: number): Promise<GameFeatureType> {\r\n    this.logger.log(`Removing feature with ID ${id}`);\r\n\r\n    // Find the feature by its ID\r\n    const feature = await this.gameFeatureRepository.findOne({ where: { id } });\r\n\r\n    // Throw a NotFoundException if the feature does not exist\r\n    if (!feature) throw new NotFoundException(`Feature with ID ${id} not found`);\r\n\r\n    // Remove the feature\r\n    const result = await this.gameFeatureRepository.remove(feature);\r\n\r\n    // Throw an InternalServerErrorException if the feature could not be removed\r\n    if (!result) throw new InternalServerErrorException('Failed to remove feature');\r\n\r\n    // Return the removed feature\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Removes all features.\r\n   * @throws `InternalServerErrorException` If the features could not be removed.\r\n   */\r\n  public async removeAll(): Promise<void> {\r\n    this.logger.log('Removing all features');\r\n\r\n    // Remove all features\r\n    const result = await this.gameFeatureRepository.delete({});\r\n\r\n    // Throw an InternalServerErrorException if the features could not be removed\r\n    if (result === undefined) throw new InternalServerErrorException('Failed to remove features');\r\n  }\r\n}\r\n"],"names":["GamesFeaturesService","constructor","logger","gameFeatureRepository","getAll","orderBy","order","log","features","find","getById","id","feature","findOne","where","NotFoundException","getByIds","ids","In","length","missingIds","filter","some","getByName","name","getFeaturesPaginated","page","limit","searchQuery","ILike","items","total","findAndCount","skip","Math","max","take","totalPages","ceil","create","existingFeature","ConflictException","newFeature","icon","createdFeature","save","InternalServerErrorException","update","undefined","updatedFeature","remove","result","removeAll","delete"],"mappings":"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"}