{"version":3,"sources":["../../../../../src/modules/apis/user/auth/auth.service.ts"],"sourcesContent":["// NestJS\r\nimport { BadRequestException, Injectable, InternalServerErrorException, Logger } from '@nestjs/common';\r\nimport { ConfigService } from '@nestjs/config';\r\n\r\n// UUID\r\nimport { randomUUID } from 'crypto';\r\n\r\n// Services\r\nimport { JwtService } from '@nestjs/jwt';\r\nimport { TokenBlacklistService } from '@repositories/mongo/token-blacklist/token-blacklist.service';\r\nimport { NodeMailerService } from '@services/node-mailer/node-mailer.service';\r\n\r\nimport { UserService } from '@apis/user/user.service'; // Api service (The Extended Service)\r\nimport { UsersService } from '@repositories/sql/users/users.service'; // Repository service (The Injected Service)\r\n\r\n// Types\r\nimport type { User } from '@repositories/sql/users/user.entity';\r\n\r\n@Injectable()\r\nexport class AuthService {\r\n  private readonly accessTokenSecret: string;\r\n  private readonly refreshTokenSecret: string;\r\n\r\n  constructor(\r\n    private readonly jwt: JwtService,\r\n    private readonly userTools: UserService,\r\n    private readonly user: UsersService,\r\n    private readonly mailer: NodeMailerService,\r\n    private readonly logger: Logger,\r\n    private readonly tokenBlacklist: TokenBlacklistService,\r\n    private readonly config: ConfigService,\r\n  ) {\r\n    this.accessTokenSecret = this.config.get('JWT_ACCESS_TOKEN_SECRET');\r\n    this.refreshTokenSecret = this.config.get('JWT_REFRESH_TOKEN_SECRET');\r\n  }\r\n\r\n  /**\r\n   * Signs up a new user\r\n   * @param data An object containing username, email, password, and country\r\n   * @returns The created user data\r\n   */\r\n  public async signup(data: {\r\n    username: string;\r\n    email: string;\r\n    password: string;\r\n    country: string;\r\n  }): Promise<{ message: string }> {\r\n    const { username, email, password, country } = data;\r\n\r\n    this.logger.log(`Signing up user ${email}`);\r\n\r\n    // Hash password\r\n    const hashedPassword = await this.userTools.hashPassword(password);\r\n\r\n    // Create user\r\n    const user = await this.user.create({\r\n      email,\r\n      username,\r\n      country,\r\n      password: hashedPassword,\r\n    });\r\n\r\n    // Create verification token\r\n    const verificationToken = await this.createVerificationToken();\r\n\r\n    // Send verification email\r\n    await this.mailer.sendVerificationEmail(user.email, user.username, verificationToken);\r\n\r\n    // Update user verification token in database\r\n    await this.user.updateVerificationToken(user.id, verificationToken);\r\n\r\n    // Send successful signup response\r\n    this.logger.log(`Signed up user with email ${email} and username ${username} successfully`);\r\n    return { message: 'Signup successful' };\r\n  }\r\n\r\n  /**\r\n   * Logs in a user\r\n   * @param data An object containing identifier, password, and rememberMe\r\n   * @returns Message, user data, access and refresh tokens if login is successful\r\n   * @throws `InternalServerErrorException` if login fails\r\n   */\r\n  public async login(data: { identifier: string; password: string; rememberMe: boolean }): Promise<{\r\n    message: string;\r\n    loggingIn: boolean;\r\n    accessToken: string;\r\n    refreshToken: string;\r\n    isSessionLoggedIn: boolean;\r\n    userData: User;\r\n  }> {\r\n    const { identifier, password, rememberMe } = data;\r\n\r\n    this.logger.log(`Logging in user with username/email: ${identifier}, rememberMe: ${rememberMe}`);\r\n\r\n    // Find the user by email or username\r\n    const user = await this.userTools.findUser(identifier, 'identifier');\r\n\r\n    // Compare password hashes\r\n    await this.userTools.comparePassword(password, user.password);\r\n\r\n    // Create and sign JWT tokens\r\n    const accessToken = await this.createJwtToken(user, '1d', 'access');\r\n    const refreshToken = await this.createJwtToken(user, '30d', 'refresh');\r\n\r\n    // SignIn User in database\r\n    await this.user.setLoginStatus(user.id, true);\r\n\r\n    // Send successful login response with tokens\r\n    this.logger.log(`Logged in user with username/email: ${identifier}`);\r\n    return {\r\n      message: 'Login successful',\r\n      loggingIn: true, // Used for setting cookies interceptor\r\n      accessToken, // Used for setting cookies interceptor\r\n      refreshToken, // Used for setting cookies interceptor\r\n      isSessionLoggedIn: rememberMe ? false : true, // Used for frontend if session is logged in\r\n      userData: user,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Auto logs in a user when reopening the browser\r\n   * @param headers The request headers, containing the refresh token\r\n   * @returns Success message, user data and access token if login is successful\r\n   * @throws `InternalServerErrorException` if user is not logged out\r\n   */\r\n  public async autoLogin(data: { userId: string }): Promise<{ message: string; userData: User; accessToken: string }> {\r\n    const { userId } = data;\r\n\r\n    this.logger.log(`Auto logging in user with id: ${userId}`);\r\n\r\n    // Get user data\r\n    const user = await this.userTools.findUser(userId, 'id');\r\n\r\n    // SignIn User in database\r\n    await this.user.setLoginStatus(user.id, true);\r\n\r\n    // Create and sign new access token\r\n    const newAccessToken = await this.createJwtToken(user, '1h', 'access');\r\n\r\n    // Send successful auto login response\r\n    this.logger.log(`Auto logged in user with id: ${userId}`);\r\n    return {\r\n      message: 'Auto login successful',\r\n      userData: user,\r\n      accessToken: newAccessToken, // Used for setting cookies interceptor\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Logs out a user\r\n   * @param headers The request headers, containing the access token\r\n   * @returns Message if logout is successful\r\n   */\r\n  public async logout(data: {\r\n    userId: string;\r\n    accessToken: string;\r\n    refreshToken: string;\r\n  }): Promise<{ message: string }> {\r\n    const { userId, accessToken, refreshToken } = data;\r\n\r\n    this.logger.log(`Logging out user with id: ${userId}`);\r\n\r\n    // set user to logged out\r\n    await this.user.setLoginStatus(userId, false);\r\n\r\n    // Blacklist access and refresh tokens\r\n    await this.tokenBlacklist.blacklistToken(accessToken);\r\n    await this.tokenBlacklist.blacklistToken(refreshToken);\r\n\r\n    // Return success message\r\n    this.logger.log(`Logged out user with id: ${userId}`);\r\n    return { message: 'Logout successful' };\r\n  }\r\n\r\n  /**\r\n   * Refreshes an access token\r\n   * @param headers The request headers, containing the refresh token\r\n   * @returns Message and new access token if refresh is successful\r\n   * @throws `InternalServerErrorException` if user is not logged in\r\n   */\r\n  public async refreshToken(data: { userId: string }): Promise<{ message: string; accessToken: string }> {\r\n    const { userId } = data;\r\n\r\n    this.logger.log(`Refreshing access token for user with id: ${userId}`);\r\n\r\n    // Get user data\r\n    const user = await this.userTools.findUser(userId, 'id');\r\n\r\n    // If user is not loggedin in database, throw an exception\r\n    if (!user.isLoggedIn) throw new InternalServerErrorException('Failed to login user');\r\n\r\n    // Create and sign new access\r\n    const newAccessToken = await this.createJwtToken(user, '1h', 'access');\r\n\r\n    // Return success message and new access token\r\n    this.logger.log(`Refreshed access token for user with id: ${userId}`);\r\n    return {\r\n      message: 'Refresh token successful',\r\n      accessToken: newAccessToken, // Used for setting cookies interceptor\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets user data\r\n   * @param headers The request headers, containing the access token\r\n   * @returns User data\r\n   */\r\n  public async getUserData(data: { userId: string }): Promise<{ userData: User }> {\r\n    const { userId } = data;\r\n\r\n    this.logger.log(`Getting user data for user with id: ${userId}`);\r\n\r\n    // Get user data\r\n    const userData = await this.userTools.findUser(userId, 'id');\r\n\r\n    // Return user data\r\n    this.logger.log(`Got user data for user with id: ${userId}`);\r\n    return { userData };\r\n  }\r\n\r\n  /**\r\n   * Gets verification status\r\n   * @param data An object containing the email\r\n   * @returns Verification status\r\n   */\r\n  public async getVerificationStatus(data: { email: string }): Promise<{ verified: boolean }> {\r\n    const { email } = data;\r\n\r\n    this.logger.log(`Getting verification status for user with email: ${email}`);\r\n\r\n    // Check and get user\r\n    const user = await this.userTools.findUser(email, 'email');\r\n\r\n    // return verification status\r\n    this.logger.log(`Got verification status for user with email: ${email}`);\r\n    return { verified: user.isVerified };\r\n  }\r\n\r\n  /**\r\n   * Resends verification token\r\n   * @param data An object containing the email\r\n   * @returns Success message\r\n   */\r\n  public async resendVerificationToken(data: { email: string }): Promise<{ message: string }> {\r\n    const { email } = data;\r\n\r\n    this.logger.log(`Resending verification token for user with email: ${email}`);\r\n\r\n    // Check and get user\r\n    const user = await this.userTools.findUser(email, 'email');\r\n\r\n    // Check if user is already verified\r\n    if (user.isVerified) {\r\n      this.logger.log(`User with email: ${email} is already verified`);\r\n      throw new BadRequestException('User is already verified');\r\n    }\r\n\r\n    // generate verification token\r\n    const verificationToken = await this.createVerificationToken();\r\n\r\n    // Send verification email\r\n    await this.mailer.sendVerificationEmail(user.email, user.username, verificationToken);\r\n\r\n    // update user verification token in database\r\n    await this.user.updateVerificationToken(user.id, verificationToken);\r\n\r\n    // Block the verification token after 20 minutes\r\n    setTimeout(\r\n      async () => {\r\n        await this.user.updateVerificationToken(user.id, null);\r\n      },\r\n      20 * 60 * 1000,\r\n    );\r\n\r\n    // Return success message\r\n    this.logger.log(`Resent verification token for user with email: ${email}`);\r\n    return { message: 'Verification email sent' };\r\n  }\r\n\r\n  /**\r\n   * Verifies email\r\n   * @param data email and verification token\r\n   * @returns success message if verification is successful\r\n   * @throws `BadRequestException` if verification token is invalid\r\n   */\r\n  public async verifyEmail(data: { username: string; token: string }): Promise<{ message: string }> {\r\n    const { username, token } = data;\r\n\r\n    this.logger.log(`Verifying email for user with username: ${username}`);\r\n\r\n    // Check and get user\r\n    const user = await this.userTools.findUser(username, 'username');\r\n\r\n    // Verify token and throw an exception if invalid\r\n    if (user.verificationToken !== token) {\r\n      this.logger.log(`Invalid verification token for user with username: ${username}`);\r\n      throw new BadRequestException('Invalid verification token');\r\n    }\r\n\r\n    // Verify user in database\r\n    await this.user.verify(user.id);\r\n\r\n    // Return success message\r\n    this.logger.log(`Verified email for user with username: ${username}`);\r\n    return { message: 'Email verified successfully' };\r\n  }\r\n\r\n  /**\r\n   * Update access and refresh token\r\n   * @param data access token and refresh token\r\n   * @returns new access token and refresh token\r\n   */\r\n  public async updateTokens(data: { userId: string; accessToken: string; refreshToken: string }): Promise<{\r\n    accessToken: string;\r\n    refreshToken: string;\r\n  }> {\r\n    const { userId, accessToken, refreshToken } = data;\r\n\r\n    this.logger.log(`Updating access and refresh token`);\r\n\r\n    // Check and get user\r\n    const user = await this.userTools.findUser(userId, 'id');\r\n\r\n    // Blacklist access and refresh tokens\r\n    await this.tokenBlacklist.blacklistToken(accessToken);\r\n    await this.tokenBlacklist.blacklistToken(refreshToken);\r\n\r\n    // Create and sign new access and refresh token\r\n    const newAccessToken = await this.createJwtToken(user, '1h', 'access');\r\n    const newRefreshToken = await this.createJwtToken(user, '30d', 'refresh');\r\n\r\n    // Return access and refresh token\r\n    this.logger.log(`Updated access and refresh token`);\r\n    return {\r\n      accessToken: newAccessToken, // Used for setting cookies interceptor\r\n      refreshToken: newRefreshToken, // Used for setting cookies interceptor\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets waiting time for email verification\r\n   * @returns Waiting time in milliseconds\r\n   */\r\n  public getWaitingTime(): { waitingTime: number } {\r\n    this.logger.log(`Getting waiting time for email verification`);\r\n    const waitingTime = 20 * 60 * 1000;\r\n    this.logger.log(`Got waiting time for email verification`);\r\n    return { waitingTime };\r\n  }\r\n\r\n  /**\r\n   * Creates a new access/refresh token\r\n   * @param user The user to create the access/refresh token for\r\n   * @param expiry The token expiry\r\n   * @param type The type of token to create\r\n   * @returns The prefixed access token\r\n   */\r\n  private async createJwtToken(user: User, expiry: string, type: 'access' | 'refresh'): Promise<string> {\r\n    this.logger.log(`Creating ${type} token for user ${user.id}`);\r\n\r\n    // Create payload\r\n    const payload = {\r\n      id: user.id,\r\n      email: user.email,\r\n      username: user.username,\r\n      admin: user.isAdmin,\r\n      verified: user.isVerified,\r\n    };\r\n\r\n    // Create jwt token\r\n    const jwtToken = await this.jwt.signAsync(payload, {\r\n      expiresIn: expiry,\r\n      secret: type === 'access' ? this.accessTokenSecret : this.refreshTokenSecret,\r\n    });\r\n\r\n    // Prefix jwt token\r\n    const prefixedJwtToken = `Bearer ${jwtToken}`;\r\n\r\n    // Return prefixed jwt token\r\n    this.logger.log(`Created ${type} token for user ${user.id}`);\r\n    return prefixedJwtToken;\r\n  }\r\n\r\n  /**\r\n   * Creates a new verification token\r\n   * @returns The verification token\r\n   */\r\n  private async createVerificationToken(): Promise<string> {\r\n    this.logger.log('Creating verification token');\r\n    // Generate verification token\r\n    const verificationToken = randomUUID();\r\n\r\n    // Send verification email\r\n    this.logger.log('Created verification token');\r\n    return verificationToken;\r\n  }\r\n}\r\n"],"names":["AuthService","constructor","jwt","userTools","user","mailer","logger","tokenBlacklist","config","accessTokenSecret","get","refreshTokenSecret","signup","data","username","email","password","country","log","hashedPassword","hashPassword","create","verificationToken","createVerificationToken","sendVerificationEmail","updateVerificationToken","id","message","login","identifier","rememberMe","findUser","comparePassword","accessToken","createJwtToken","refreshToken","setLoginStatus","loggingIn","isSessionLoggedIn","userData","autoLogin","userId","newAccessToken","logout","blacklistToken","isLoggedIn","InternalServerErrorException","getUserData","getVerificationStatus","verified","isVerified","resendVerificationToken","BadRequestException","setTimeout","verifyEmail","token","verify","updateTokens","newRefreshToken","getWaitingTime","waitingTime","expiry","type","payload","admin","isAdmin","jwtToken","signAsync","expiresIn","secret","prefixedJwtToken","randomUUID"],"mappings":"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"}