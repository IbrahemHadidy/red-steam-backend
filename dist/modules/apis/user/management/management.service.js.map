{"version":3,"sources":["../../../../../src/modules/apis/user/management/management.service.ts"],"sourcesContent":["// NestJS\r\nimport { BadRequestException, ConflictException, Injectable, Logger, UnauthorizedException } from '@nestjs/common';\r\nimport { ConfigService } from '@nestjs/config';\r\n\r\n// Services\r\nimport { JwtService } from '@nestjs/jwt';\r\nimport { TokenBlacklistService } from '@repositories/mongo/token-blacklist/token-blacklist.service';\r\nimport { AvatarStorageService } from '@services/dropbox/avatar-storage.service';\r\nimport { NodeMailerService } from '@services/node-mailer/node-mailer.service';\r\n\r\nimport { UserService } from '@apis/user/user.service'; // Api service (The Extended Service)\r\nimport { UsersService } from '@repositories/sql/users/users.service'; // Repository service (The Injected Service)\r\n\r\n// Types\r\nimport type { File } from '@nest-lab/fastify-multer';\r\n\r\n@Injectable()\r\nexport class ManagementService {\r\n  private readonly resetTokenSecret: string;\r\n\r\n  constructor(\r\n    private readonly jwt: JwtService,\r\n    private readonly userTools: UserService,\r\n    private readonly user: UsersService,\r\n    private readonly mailer: NodeMailerService,\r\n    private readonly logger: Logger,\r\n    private readonly config: ConfigService,\r\n    private readonly tokenBlacklist: TokenBlacklistService,\r\n    private readonly avatarStorage: AvatarStorageService,\r\n  ) {\r\n    this.resetTokenSecret = this.config.get('JWT_RESET_TOKEN_SECRET');\r\n  }\r\n\r\n  /**\r\n   * Check if email exists\r\n   * @param email The email to check\r\n   * @returns The result of the check\r\n   */\r\n  public async checkEmailExists(data: { email: string }): Promise<{ exists: boolean; message: string }> {\r\n    const { email } = data;\r\n\r\n    this.logger.log(`Checking if email exists: ${email}`);\r\n\r\n    // Get user by email\r\n    const user = await this.user.getByEmail(email);\r\n\r\n    // If email exists, return true\r\n    if (user) return { exists: true, message: 'Email already exists' };\r\n\r\n    // Else return false\r\n    return { exists: false, message: 'Email available' };\r\n  }\r\n\r\n  /**\r\n   * Check if username exists\r\n   * @param username The username to check\r\n   * @returns The result of the check\r\n   */\r\n  public async checkUsernameExists(data: { username: string }): Promise<{ exists: boolean; message: string }> {\r\n    const { username } = data;\r\n\r\n    this.logger.log(`Checking if username exists: ${username}`);\r\n\r\n    // Get user by username\r\n    const user = await this.user.getByUsername(username);\r\n\r\n    // If username exists, return true\r\n    if (user) return { exists: true, message: 'Username already exists' };\r\n\r\n    // Else return false\r\n    return { exists: false, message: 'Username available' };\r\n  }\r\n\r\n  /**\r\n   * Change username\r\n   * @param data An object containing the userId, password, and newUsername\r\n   * @returns The result of the change\r\n   * @throws `ConflictException` If the new username already exists\r\n   * @throws `BadRequestException` If the new username is the same as the current one\r\n   */\r\n  public async changeUsername(data: {\r\n    userId: string;\r\n    currentPassword: string;\r\n    newUsername: string;\r\n  }): Promise<{ message: string }> {\r\n    const { userId, currentPassword, newUsername } = data;\r\n\r\n    this.logger.log(`Changing username for user with id: ${userId} to: ${newUsername}`);\r\n\r\n    // Check and get user\r\n    const user = await this.userTools.findUser(userId, 'id');\r\n\r\n    // Compare password hashes\r\n    await this.userTools.comparePassword(currentPassword, user.password);\r\n\r\n    // Check if new username is the same as the old one\r\n    if (newUsername === user.username) {\r\n      this.logger.warn(`New username must be different from the current one for userId: ${userId}`);\r\n      throw new BadRequestException('New username must be different');\r\n    }\r\n\r\n    // Check if new username is available\r\n    const checkUsername = await this.checkUsernameExists({ username: newUsername });\r\n    if (checkUsername.exists) {\r\n      this.logger.warn(`Username already exists: ${newUsername}`);\r\n      throw new ConflictException('Username already exists');\r\n    }\r\n\r\n    // Update username\r\n    await this.user.updateUsername(userId, newUsername);\r\n\r\n    // Return success\r\n    this.logger.log(`Username changed successfully for userId: ${userId}`);\r\n    return { message: 'Username changed successfully' };\r\n  }\r\n\r\n  /**\r\n   * Change email\r\n   * @param data An object containing the userId, password, currentEmail, and newEmail\r\n   * @returns The result of the change\r\n   * @throws `UnauthorizedException` If the current email is incorrect\r\n   * @throws `BadRequestException` If the new email is the same as the current one\r\n   * @throws `ConflictException` If the new email already exists\r\n   */\r\n  public async changeEmail(data: {\r\n    userId: string;\r\n    currentPassword: string;\r\n    currentEmail: string;\r\n    newEmail: string;\r\n  }): Promise<{ message: string }> {\r\n    const { userId, currentPassword, currentEmail, newEmail } = data;\r\n\r\n    this.logger.log(`Changing email for user with id: ${userId} to: ${newEmail}`);\r\n\r\n    // Check and get user\r\n    const user = await this.userTools.findUser(userId, 'id');\r\n\r\n    // Compare password hashes\r\n    await this.userTools.comparePassword(currentPassword, user.password);\r\n\r\n    // Check if current email is the same as the old one\r\n    if (currentEmail !== user.email) {\r\n      this.logger.warn(`Current email is incorrect for userId: ${userId}`);\r\n      throw new UnauthorizedException('Current email is incorrect');\r\n    }\r\n\r\n    // Check if new email is the same as the old one\r\n    if (newEmail === user.email) {\r\n      this.logger.warn(`New email must be different from the current one for userId: ${userId}`);\r\n      throw new BadRequestException('New email must be different');\r\n    }\r\n\r\n    // Check if new email is available\r\n    const checkEmail = await this.checkEmailExists({ email: newEmail });\r\n    if (checkEmail.exists) {\r\n      this.logger.warn(`Email already exists: ${newEmail}`);\r\n      throw new ConflictException('Email already exists');\r\n    }\r\n\r\n    // Update email\r\n    await this.user.updateEmail(userId, newEmail, true);\r\n\r\n    // Return success message\r\n    this.logger.log(`Email changed successfully for userId: ${userId}`);\r\n    return { message: 'Email changed successfully, please verify your email' };\r\n  }\r\n\r\n  /**\r\n   * Change country\r\n   * @param data An object containing the userId and newCountry\r\n   * @returns The result of the change\r\n   * @throws `BadRequestException` If the new country is the same as the current one\r\n   */\r\n  public async changeCountry(data: { userId: string; newCountry: string }): Promise<{ message: string }> {\r\n    const { userId, newCountry } = data;\r\n\r\n    this.logger.log(`Changing country for user with id: ${userId} to: ${newCountry}`);\r\n\r\n    // Check and get user\r\n    const user = await this.userTools.findUser(userId, 'id');\r\n\r\n    // Check if new country is the same as the old one\r\n    if (newCountry === user.country) {\r\n      this.logger.warn(`New country must be different from the current one for userId: ${userId}`);\r\n      throw new BadRequestException('New country must be different');\r\n    }\r\n\r\n    // Update country\r\n    await this.user.updateCountry(userId, newCountry);\r\n\r\n    // Return success message\r\n    this.logger.log(`Country changed successfully for userId: ${userId}`);\r\n    return { message: 'Country changed successfully' };\r\n  }\r\n\r\n  /**\r\n   * Upload avatar\r\n   * @param avatar The avatar to upload\r\n   * @param userId The user id to upload the avatar\r\n   * @returns The result of the upload\r\n   */\r\n  public async uploadAvatar(data: { avatar: File; userId: string }): Promise<{ message: string }> {\r\n    const { avatar, userId } = data;\r\n\r\n    this.logger.log(`Uploading avatar for user with id: ${userId}`);\r\n\r\n    // Check and get user\r\n    const user = await this.userTools.findUser(userId, 'id');\r\n\r\n    // Delete old avatar\r\n    if (user.profilePicture) {\r\n      const oldAvatar = user.profilePicture.split('/avatar-')[1].split('?')[0];\r\n      await this.avatarStorage.deleteAvatar(`/avatars/avatar-${oldAvatar}`);\r\n      this.user.removeAvatar(userId);\r\n    }\r\n\r\n    // Upload avatar\r\n    const uploadResponse = await this.avatarStorage.uploadAvatar(avatar);\r\n\r\n    // Update the user's profile picture in the database\r\n    await this.user.updateAvatar(userId, uploadResponse.sharedLink);\r\n\r\n    // Return success message\r\n    this.logger.log(`Avatar uploaded successfully for userId: ${userId}`);\r\n    return { message: 'Avatar uploaded successfully' };\r\n  }\r\n\r\n  /**\r\n   * Delete avatar\r\n   * @param userId The user id to delete the avatar\r\n   * @returns The result of the delete\r\n   */\r\n  public async deleteAvatar(data: { userId: string }): Promise<{ message: string }> {\r\n    const { userId } = data;\r\n\r\n    this.logger.log(`Deleting avatar for user with id: ${userId}`);\r\n\r\n    // Check and get user\r\n    const user = await this.userTools.findUser(userId, 'id');\r\n\r\n    // Delete old avatar\r\n    const oldAvatar = user.profilePicture.split('/avatar-')[1].split('?')[0];\r\n    if (user.profilePicture) await this.avatarStorage.deleteAvatar(`/avatars/avatar-${oldAvatar}`);\r\n\r\n    // Update the user's profile picture in the database to null\r\n    await this.user.removeAvatar(userId);\r\n\r\n    // Return success message\r\n    this.logger.log(`Avatar deleted successfully for userId: ${userId}`);\r\n    return { message: 'Avatar deleted successfully' };\r\n  }\r\n\r\n  /**\r\n   * Change password\r\n   * @param data An object containing the userId, oldPassword, and newPassword\r\n   * @returns The result of the change\r\n   * @throws `BadRequestException` If the new password is the same as the old one\r\n   */\r\n  public async changePassword(data: {\r\n    userId: string;\r\n    currentPassword: string;\r\n    newPassword: string;\r\n  }): Promise<{ message: string }> {\r\n    const { userId, currentPassword, newPassword } = data;\r\n\r\n    this.logger.log(`Changing password for user with id: ${userId}`);\r\n\r\n    // Check and get user\r\n    const user = await this.userTools.findUser(userId, 'id');\r\n\r\n    // Compare password hashes\r\n    await this.userTools.comparePassword(currentPassword, user.password);\r\n\r\n    // Check if new password is the same as the old one\r\n    if (newPassword === currentPassword) {\r\n      this.logger.warn(`New password must be different from the current one for userId: ${userId}`);\r\n      throw new BadRequestException('New password must be different');\r\n    }\r\n\r\n    // Hash password\r\n    const hashedPassword = await this.userTools.hashPassword(newPassword);\r\n\r\n    // Update password\r\n    await this.user.updatePassword(userId, hashedPassword);\r\n\r\n    // Return success message\r\n    this.logger.log(`Password changed successfully for userId: ${userId}`);\r\n    return { message: 'Password changed successfully' };\r\n  }\r\n\r\n  /**\r\n   * Forgot password\r\n   * @param data An object containing the email\r\n   * @returns The result of the change\r\n   */\r\n  public async forgotPassword(data: { email: string }): Promise<{ message: string }> {\r\n    const { email } = data;\r\n\r\n    this.logger.log(`Sending password reset email for email: ${email}`);\r\n\r\n    // Check if email exists\r\n    const user = await this.userTools.findUser(email, 'email');\r\n\r\n    // Generate a password reset token\r\n    const resetToken = await this.generateResetToken(email);\r\n\r\n    // Send password reset email\r\n    await this.mailer.sendPasswordResetEmail(email, user.username, resetToken);\r\n\r\n    // Set user's verification token\r\n    await this.user.updateVerificationToken(user.id, resetToken);\r\n\r\n    // Return success message\r\n    this.logger.log(`Password reset email sent for email: ${email}`);\r\n    return { message: 'Reset email sent successfully' };\r\n  }\r\n\r\n  /**\r\n   * Submit password reset\r\n   * @param data An object containing the token and newPassword\r\n   * @returns The result of the change\r\n   * @throws `UnauthorizedException` If the token is blacklisted\r\n   */\r\n  public async passwordReset(data: { token: string; newPassword: string }): Promise<{ message: string }> {\r\n    const { token, newPassword } = data;\r\n\r\n    this.logger.log(`Submitting password reset for token: ${token}`);\r\n\r\n    // Verify token\r\n    const userEmail = await this.verifyResetToken(token);\r\n\r\n    // Check and get user\r\n    const user = await this.userTools.findUser(userEmail, 'email');\r\n\r\n    // Check if token is blacklisted\r\n    const isBlacklisted = await this.tokenBlacklist.isBlacklisted(token);\r\n    if (isBlacklisted) {\r\n      this.logger.warn(`Token ${token} is blacklisted`);\r\n      throw new UnauthorizedException('Token is blacklisted');\r\n    }\r\n\r\n    // Hash password\r\n    const hashedPassword = await this.userTools.hashPassword(newPassword);\r\n\r\n    // Update password\r\n    await this.user.updatePassword(user.id, hashedPassword);\r\n\r\n    // Blacklist token if not in test mode\r\n    if (process.env.NODE_ENV !== 'test') {\r\n      await this.tokenBlacklist.blacklistToken(token);\r\n    }\r\n\r\n    // Return success message\r\n    this.logger.log(`Password reset successful for userId: ${user.id}`);\r\n    return { message: 'Password reset successful' };\r\n  }\r\n\r\n  /**\r\n   * Delete account\r\n   * @param data An object containing the userId and password\r\n   * @returns The result of the delete\r\n   */\r\n  public async deleteAccount(data: { userId: string; currentPassword: string }): Promise<{ message: string }> {\r\n    const { userId, currentPassword } = data;\r\n\r\n    this.logger.log(`Deleting account for user with id: ${userId}`);\r\n\r\n    // Check and get user\r\n    const user = await this.userTools.findUser(userId, 'id');\r\n\r\n    // Compare password hashes\r\n    await this.userTools.comparePassword(currentPassword, user.password);\r\n\r\n    // Delete user\r\n    await this.user.remove(userId);\r\n\r\n    // Return success message\r\n    this.logger.log(`Account deleted successfully for userId: ${userId}`);\r\n    return { message: 'Account deleted successfully' };\r\n  }\r\n\r\n  /**\r\n   * Generates a reset token\r\n   * @param id The user id to generate the token for\r\n   * @returns The generated token\r\n   */\r\n  private async generateResetToken(email: string): Promise<string> {\r\n    this.logger.log(`Generating reset token for email: ${email}`);\r\n\r\n    // if in test mode, return 'test-reset-token' (used for e2e testing)\r\n    if (process.env.NODE_ENV === 'test') {\r\n      return 'test-reset-token';\r\n    }\r\n\r\n    const payload = { email };\r\n\r\n    // Generate reset token\r\n    const resetToken = await this.jwt.signAsync(payload, {\r\n      expiresIn: '1h',\r\n      secret: this.resetTokenSecret,\r\n    });\r\n    return resetToken;\r\n  }\r\n\r\n  /**\r\n   * Verifies a reset token\r\n   * @param token The token to verify\r\n   * @returns The user id if the token is valid\r\n   * @throws `UnauthorizedException` If the token is invalid\r\n   */\r\n  private async verifyResetToken(token: string): Promise<string> {\r\n    this.logger.log(`Verifying reset token: ${token}`);\r\n\r\n    // if in test mode, return 'testuser3@me.com' (used for e2e testing)\r\n    if (process.env.NODE_ENV === 'test') {\r\n      if (token === 'test-reset-token') {\r\n        return 'testuser3@me.com';\r\n      } else {\r\n        throw new UnauthorizedException('Invalid token');\r\n      }\r\n    }\r\n\r\n    try {\r\n      const decoded = await this.jwt.verifyAsync(token, {\r\n        secret: this.resetTokenSecret,\r\n      });\r\n\r\n      return decoded.email;\r\n    } catch (error) {\r\n      throw new UnauthorizedException('Invalid token');\r\n    }\r\n  }\r\n}\r\n"],"names":["ManagementService","constructor","jwt","userTools","user","mailer","logger","config","tokenBlacklist","avatarStorage","resetTokenSecret","get","checkEmailExists","data","email","log","getByEmail","exists","message","checkUsernameExists","username","getByUsername","changeUsername","userId","currentPassword","newUsername","findUser","comparePassword","password","warn","BadRequestException","checkUsername","ConflictException","updateUsername","changeEmail","currentEmail","newEmail","UnauthorizedException","checkEmail","updateEmail","changeCountry","newCountry","country","updateCountry","uploadAvatar","avatar","profilePicture","oldAvatar","split","deleteAvatar","removeAvatar","uploadResponse","updateAvatar","sharedLink","changePassword","newPassword","hashedPassword","hashPassword","updatePassword","forgotPassword","resetToken","generateResetToken","sendPasswordResetEmail","updateVerificationToken","id","passwordReset","token","userEmail","verifyResetToken","isBlacklisted","process","env","NODE_ENV","blacklistToken","deleteAccount","remove","payload","signAsync","expiresIn","secret","decoded","verifyAsync","error"],"mappings":"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"}