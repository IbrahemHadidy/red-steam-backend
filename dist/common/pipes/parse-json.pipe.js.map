{"version":3,"sources":["../../../src/common/pipes/parse-json.pipe.ts"],"sourcesContent":["// NestJS\r\nimport { BadRequestException, Injectable } from '@nestjs/common';\r\n\r\n// Class-transformer\r\nimport { plainToClass } from 'class-transformer';\r\n\r\n// Class-validator\r\nimport { validateSync } from 'class-validator';\r\n\r\n// Types\r\nimport type { PipeTransform } from '@nestjs/common';\r\nimport type { ValidationError } from 'class-validator';\r\n\r\n/**\r\n * Pipe to parse JSON data\r\n * @param dto - DTO class\r\n * @param options - Options for the pipe: optional\r\n * @returns Parsed data\r\n * @throws BadRequestException if JSON data is invalid or missing\r\n */\r\n@Injectable()\r\nexport class ParseJsonPipe<T extends object> implements PipeTransform<string, T> {\r\n  private readonly options: { optional?: boolean; validate?: boolean; excludeExtraneousValues?: boolean };\r\n  private readonly dto: new () => T;\r\n\r\n  constructor(\r\n    dto: new () => T,\r\n    options: { optional?: boolean; validate?: boolean; excludeExtraneousValues?: boolean } = {\r\n      optional: false,\r\n      validate: false,\r\n      excludeExtraneousValues: true,\r\n    },\r\n  ) {\r\n    this.dto = dto;\r\n    this.options = options;\r\n  }\r\n\r\n  public transform(value: string): T {\r\n    if (!value || typeof value !== 'string') {\r\n      if (!this.options.optional) {\r\n        throw new BadRequestException('Missing required JSON query');\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    const jsonValue = JSON.parse(value);\r\n\r\n    // Only parse if the onlyParse option is set\r\n    if (this.options.validate === false) {\r\n      return jsonValue;\r\n    }\r\n\r\n    const dtoObject = plainToClass(this.dto, jsonValue, {\r\n      excludeExtraneousValues: this.options.excludeExtraneousValues,\r\n    });\r\n\r\n    const errors = validateSync(dtoObject);\r\n    if (errors.length > 0) {\r\n      const errorMessages = errors.map((error: ValidationError) => this.formatValidationErrors(error)).join(', ');\r\n\r\n      throw new BadRequestException(`Validation failed: ${errorMessages}`);\r\n    }\r\n\r\n    return dtoObject;\r\n  }\r\n\r\n  private formatValidationErrors(error: ValidationError): string {\r\n    if (error.children && error.children.length > 0) {\r\n      return error.children.map((child) => this.formatValidationErrors(child)).join(', ');\r\n    }\r\n\r\n    return Object.values(error.constraints || {}).join(', ');\r\n  }\r\n}\r\n"],"names":["ParseJsonPipe","constructor","dto","options","optional","validate","excludeExtraneousValues","transform","value","BadRequestException","undefined","jsonValue","JSON","parse","dtoObject","plainToClass","errors","validateSync","length","errorMessages","map","error","formatValidationErrors","join","children","child","Object","values","constraints"],"mappings":"AAAA,SAAS;;;;;+BAqBIA;;;eAAAA;;;wBApBmC;kCAGnB;gCAGA;;;;;;;;;;AActB,IAAA,AAAMA,gBAAN,MAAMA;IAIXC,YACEC,GAAgB,EAChBC,UAAyF;QACvFC,UAAU;QACVC,UAAU;QACVC,yBAAyB;IAC3B,CAAC,CACD;QACA,IAAI,CAACJ,GAAG,GAAGA;QACX,IAAI,CAACC,OAAO,GAAGA;IACjB;IAEOI,UAAUC,KAAa,EAAK;QACjC,IAAI,CAACA,SAAS,OAAOA,UAAU,UAAU;YACvC,IAAI,CAAC,IAAI,CAACL,OAAO,CAACC,QAAQ,EAAE;gBAC1B,MAAM,IAAIK,2BAAmB,CAAC;YAChC;YACA,OAAOC;QACT;QAEA,MAAMC,YAAYC,KAAKC,KAAK,CAACL;QAE7B,4CAA4C;QAC5C,IAAI,IAAI,CAACL,OAAO,CAACE,QAAQ,KAAK,OAAO;YACnC,OAAOM;QACT;QAEA,MAAMG,YAAYC,IAAAA,8BAAY,EAAC,IAAI,CAACb,GAAG,EAAES,WAAW;YAClDL,yBAAyB,IAAI,CAACH,OAAO,CAACG,uBAAuB;QAC/D;QAEA,MAAMU,SAASC,IAAAA,4BAAY,EAACH;QAC5B,IAAIE,OAAOE,MAAM,GAAG,GAAG;YACrB,MAAMC,gBAAgBH,OAAOI,GAAG,CAAC,CAACC,QAA2B,IAAI,CAACC,sBAAsB,CAACD,QAAQE,IAAI,CAAC;YAEtG,MAAM,IAAId,2BAAmB,CAAC,CAAC,mBAAmB,EAAEU,eAAe;QACrE;QAEA,OAAOL;IACT;IAEQQ,uBAAuBD,KAAsB,EAAU;QAC7D,IAAIA,MAAMG,QAAQ,IAAIH,MAAMG,QAAQ,CAACN,MAAM,GAAG,GAAG;YAC/C,OAAOG,MAAMG,QAAQ,CAACJ,GAAG,CAAC,CAACK,QAAU,IAAI,CAACH,sBAAsB,CAACG,QAAQF,IAAI,CAAC;QAChF;QAEA,OAAOG,OAAOC,MAAM,CAACN,MAAMO,WAAW,IAAI,CAAC,GAAGL,IAAI,CAAC;IACrD;AACF"}